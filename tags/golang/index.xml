<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on 星河</title>
    <link>/tags/golang/</link>
    <description>Recent content in Golang on 星河</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 15 Mar 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go 面试题目</title>
      <link>/post/2023/03/15/44/</link>
      <pubDate>Wed, 15 Mar 2023 00:00:00 +0000</pubDate>
      <guid>/post/2023/03/15/44/</guid>
      <description>&lt;ol&gt;&#xA;&lt;li&gt;slice 底层原理、扩容机制&lt;/li&gt;&#xA;&lt;li&gt;map 底层原理、扩容机制&lt;/li&gt;&#xA;&lt;li&gt;channel 底层原理 环形缓存+双队列&lt;/li&gt;&#xA;&lt;li&gt;context 原理、应用场景&lt;/li&gt;&#xA;&lt;li&gt;GMP模型&lt;/li&gt;&#xA;&lt;li&gt;GC策略&lt;/li&gt;&#xA;&lt;li&gt;new 和 make 的区别&lt;/li&gt;&#xA;&lt;li&gt;map 如何知道自己处于竞争状态&lt;/li&gt;&#xA;&lt;li&gt;defer、recover、panic 实现原理&lt;/li&gt;&#xA;&lt;li&gt;二叉树 树的遍历 前中后序遍历、深度和广度&lt;/li&gt;&#xA;&lt;li&gt;平衡二叉树 左旋转、右旋转&lt;/li&gt;&#xA;&lt;li&gt;分布式一致性 ACID、CAP、BASE理论推荐&lt;/li&gt;&#xA;&lt;li&gt;Mysql 分库分表方式&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Golang 简易WS服务 - 客户端</title>
      <link>/post/2023/02/21/42/</link>
      <pubDate>Tue, 21 Feb 2023 00:00:00 +0000</pubDate>
      <guid>/post/2023/02/21/42/</guid>
      <description>&lt;p&gt;客户端代码较为简单&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;&#xD;&#xA;type SocketClient struct {&#xD;&#xA;&#x9;host        string&#xD;&#xA;&#x9;isClosed    chan bool&#xD;&#xA;&#x9;log         *logger.Log // 自定义的log包&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;type wsMessage struct {&#xD;&#xA;&#x9;Type int         `json:&amp;quot;type&amp;quot;`&#xD;&#xA;&#x9;Data interface{} `json:&amp;quot;data&amp;quot;`&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func NewSocketClient(configPath, logPath, host string) *SocketClient {&#xD;&#xA;&#x9;w := io.MultiWriter(os.Stdout)&#xD;&#xA;&#x9;if logPath != &amp;quot;&amp;quot; {&#xD;&#xA;&#x9;&#x9;f, err := util.OpenFile(logPath)&#xD;&#xA;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;panic(err)&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;w = io.MultiWriter(os.Stdout, f)&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;return &amp;amp;SocketClient{&#xD;&#xA;&#x9;&#x9;host:        host,&#xD;&#xA;&#x9;&#x9;isClosed:    make(chan bool),&#xD;&#xA;&#x9;&#x9;log:         logger.New(w, logger.LINFO, log.LstdFlags|log.Lmsgprefix),&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func (s *SocketClient) Start() {&#xD;&#xA;&#x9;// 设置在线&#xD;&#xA;&#x9;ClientStatus = ClientStatusOnline&#xD;&#xA;&#xD;&#xA;&#x9;// 连接服务器&#xD;&#xA;&#x9;u := url.URL{Scheme: &amp;quot;ws&amp;quot;, Host: s.host, Path: &amp;quot;/socket&amp;quot;}&#xD;&#xA;&#x9;s.log.Info(&amp;quot;正在连接到&amp;quot;, u.String())&#xD;&#xA;&#xD;&#xA;&#x9;conn, _, err := websocket.DefaultDialer.Dial(u.String(), nil)&#xD;&#xA;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;s.log.ErrorF(&amp;quot;连接到服务器错误: %v&amp;quot;, err)&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;defer conn.Close()&#xD;&#xA;&#xD;&#xA;&#x9;s.log.Info(&amp;quot;已连接到服务器&amp;quot;)&#xD;&#xA;&#xD;&#xA;&#x9;interrupt := make(chan os.Signal, 1)&#xD;&#xA;&#xD;&#xA;&#x9;// 监听中断信号&#xD;&#xA;&#x9;signal.Notify(interrupt, syscall.SIGKILL, syscall.SIGINT, syscall.SIGTERM, os.Kill)&#xD;&#xA;&#x9;// 心跳包&#xD;&#xA;&#x9;go s.pingHandler(conn)&#xD;&#xA;&#x9;// 接收消息&#xD;&#xA;&#x9;go s.receiveHandler(conn)&#xD;&#xA;&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;case &amp;lt;-interrupt:&#xD;&#xA;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;收到SIGINT中断信号，正在关闭ws连接。。。&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;_ = conn.WriteControl(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, &amp;quot;&amp;quot;), time.Now().Add(time.Second))&#xD;&#xA;&#x9;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;&#x9;case &amp;lt;-s.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;WS链接已关闭，退出中。。。&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;case &amp;lt;-time.After(time.Duration(1) * time.Second):&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;关闭ws链接超时，退出中。。。&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;case &amp;lt;-s.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;ws链接已关闭，退出中。。。&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func (s *SocketClient) pingHandler(conn *websocket.Conn) {&#xD;&#xA;&#x9;ticker := time.NewTicker(pingTime)&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;case &amp;lt;-ticker.C:&#xD;&#xA;&#x9;&#x9;&#x9;status := strconv.FormatInt(int64(ClientStatus), 10)&#xD;&#xA;&#x9;&#x9;&#x9;err := conn.WriteMessage(websocket.PingMessage, []byte(status))&#xD;&#xA;&#x9;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;s.log.ErrorF(&amp;quot;发送心跳包错误: %v&amp;quot;, err)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;case &amp;lt;-s.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func (s *SocketClient) receiveHandler(ws *websocket.Conn) {&#xD;&#xA;&#x9;defer close(s.isClosed)&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;messageType, message, err := ws.ReadMessage()&#xD;&#xA;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;s.log.ErrorF(&amp;quot;读取消息 %v&amp;quot;, err)&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;switch messageType {&#xD;&#xA;&#x9;&#x9;case websocket.TextMessage:&#xD;&#xA;&#x9;&#x9;&#x9;var textMessage *wsMessage&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;&#x9;err = json.Unmarshal(message, &amp;amp;textMessage)&#xD;&#xA;&#x9;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;s.log.ErrorF(&amp;quot;消息格式错误: %v&amp;quot;, err)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;&#x9;switch textMessage.Type {&#xD;&#xA;&#x9;&#x9;&#x9;        ...&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Golang 简易WS服务 - 服务端</title>
      <link>/post/2023/02/21/39/</link>
      <pubDate>Tue, 21 Feb 2023 00:00:00 +0000</pubDate>
      <guid>/post/2023/02/21/39/</guid>
      <description>&lt;h2 id=&#34;本次开发主要使用了gorilla-websocket软件包&#34;&gt;本次开发主要使用了Gorilla Websocket软件包&lt;/h2&gt;&#xA;&lt;h3 id=&#34;客户端结构体&#34;&gt;客户端结构体&lt;/h3&gt;&#xA;&lt;p&gt;维护socket连接，保存客户端信息&lt;/p&gt;&#xA;&lt;h4 id=&#34;代码&#34;&gt;代码&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package contorller&#xD;&#xA;&#xD;&#xA;import (&#xD;&#xA;&#x9;&amp;quot;encoding/json&amp;quot;&#xD;&#xA;&#x9;&amp;quot;fmt&amp;quot;&#xD;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/model&amp;quot;&#xD;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/enum&amp;quot;&#xD;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/logger&amp;quot;&#xD;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/response&amp;quot;&#xD;&#xA;&#x9;&amp;quot;github.com/gorilla/websocket&amp;quot;&#xD;&#xA;&#x9;&amp;quot;strconv&amp;quot;&#xD;&#xA;&#x9;&amp;quot;time&amp;quot;&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;const (&#xD;&#xA;&#x9;// pingWait is the maximum time in seconds to wait for a ping from&#xD;&#xA;&#x9;pingWait = 20 * time.Second&#xD;&#xA;&#x9;// Maximum message size allowed from peer.&#xD;&#xA;&#x9;maxMessageSize = 512&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;type wsClient struct {&#xD;&#xA;&#x9;manager  *wsManager&#xD;&#xA;&#x9;id       string&#xD;&#xA;&#x9;desc     string&#xD;&#xA;&#x9;conn     *websocket.Conn&#xD;&#xA;&#x9;status   enum.ClientStatus&#xD;&#xA;&#x9;send     chan []byte&#xD;&#xA;&#x9;isClosed chan bool&#xD;&#xA;&#x9;lastPing time.Time&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func newWsClient(manager *wsManager, conn *websocket.Conn, id, name, ip string) *wsClient {&#xD;&#xA;&#x9;return &amp;amp;wsClient{&#xD;&#xA;&#x9;&#x9;manager:  manager,&#xD;&#xA;&#x9;&#x9;id:       id,&#xD;&#xA;&#x9;&#x9;desc:     fmt.Sprintf(&amp;quot;客户端(%s, %s)&amp;quot;, name, ip),&#xD;&#xA;&#x9;&#x9;conn:     conn,&#xD;&#xA;&#x9;&#x9;status:   enum.ClientStatusOffline,&#xD;&#xA;&#x9;&#x9;send:     make(chan []byte),&#xD;&#xA;&#x9;&#x9;isClosed: make(chan bool),&#xD;&#xA;&#x9;&#x9;lastPing: time.Now(),&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// Read 读取客户端发送过来的消息&#xD;&#xA;func (c *wsClient) Read() {&#xD;&#xA;&#x9;defer func() {&#xD;&#xA;&#x9;&#x9;c.unRegister()&#xD;&#xA;&#x9;&#x9;logger.Info(c.desc, &amp;quot;read协程退出&amp;quot;)&#xD;&#xA;&#x9;}()&#xD;&#xA;&#xD;&#xA;&#x9;c.conn.SetReadLimit(maxMessageSize)&#xD;&#xA;&#x9;c.conn.SetPingHandler(func(text string) error {&#xD;&#xA;&#x9;&#x9;// 只需要知道客户端还活着就行，不需要回复&#xD;&#xA;&#x9;&#x9;c.lastPing = time.Now()&#xD;&#xA;&#x9;&#x9;// 更新客户端状态&#xD;&#xA;&#x9;&#x9;clientStatus, _ := strconv.ParseInt(text, 10, 32)&#xD;&#xA;&#x9;&#x9;c.status = enum.ClientStatus(int32(clientStatus))&#xD;&#xA;&#x9;&#x9;return nil&#xD;&#xA;&#x9;})&#xD;&#xA;&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;msgType, data, err := c.conn.ReadMessage()&#xD;&#xA;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;logger.Error(c.desc, &amp;quot;c.conn.ReadMessage&amp;quot;, err.Error())&#xD;&#xA;&#x9;&#x9;&#x9;break&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;switch msgType {&#xD;&#xA;&#x9;&#x9;case websocket.TextMessage:&#xD;&#xA;&#x9;&#x9;&#x9;var msg *model.WsMessage&#xD;&#xA;&#x9;&#x9;&#x9;err = json.Unmarshal(data, &amp;amp;msg)&#xD;&#xA;&#x9;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;logger.Error(c.desc, &amp;quot;json.Unmarshal&amp;quot;, err.Error())&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;&#x9;switch msg.Type {&#xD;&#xA;&#x9;&#x9;&#x9;default:&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;logger.Info(c.desc, &amp;quot;未知消息类型&amp;quot;, string(data))&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;c.send &amp;lt;- data&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// Write 把对应消息写回客户端&#xD;&#xA;func (c *wsClient) Write() {&#xD;&#xA;&#x9;defer func() {&#xD;&#xA;&#x9;&#x9;logger.Info(c.desc, &amp;quot;write协程退出&amp;quot;)&#xD;&#xA;&#x9;&#x9;c.unRegister()&#xD;&#xA;&#x9;}()&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;case &amp;lt;-c.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;case msg := &amp;lt;-c.send:&#xD;&#xA;&#x9;&#x9;&#x9;err := c.conn.WriteMessage(websocket.TextMessage, msg)&#xD;&#xA;&#x9;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;logger.Error(c.desc, &amp;quot;c.conn.WriteMessage&amp;quot;, err.Error())&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// Check 检测客户端是否超时&#xD;&#xA;func (c *wsClient) Check() {&#xD;&#xA;&#x9;defer func() {&#xD;&#xA;&#x9;&#x9;logger.Info(c.desc, &amp;quot;check协程退出&amp;quot;)&#xD;&#xA;&#x9;}()&#xD;&#xA;&#x9;ticker := time.NewTicker(pingWait / 6)&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;case &amp;lt;-c.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;case &amp;lt;-ticker.C:&#xD;&#xA;&#x9;&#x9;&#x9;// 主动关闭连接&#xD;&#xA;&#x9;&#x9;&#x9;if time.Now().Sub(c.lastPing) &amp;gt; pingWait {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;response.WsReturnErr(c.conn, enum.WsDataErr, &amp;quot;客户端超时，主动关闭连接&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;logger.Info(c.desc, &amp;quot;客户端超时，主动关闭连接&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func (c *wsClient) unRegister() {&#xD;&#xA;&#x9;if c.manager.clients[c.id] != nil {&#xD;&#xA;&#x9;&#x9;c.manager.unRegister &amp;lt;- c&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;&#xA;&lt;p&gt;应当在控制器/入口处&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 协程更好的进行错误处理</title>
      <link>/post/2022/06/02/29/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      <guid>/post/2022/06/02/29/</guid>
      <description>&lt;h2 id=&#34;利用-channel-来传输多个-goroutine-中的-errors&#34;&gt;利用 &lt;code&gt;channel&lt;/code&gt; 来传输多个 goroutine 中的 errors&lt;/h2&gt;&#xA;&lt;p&gt;Go 的经典哲学：不要通过共享内存来通信，而是通过通信来实现内存共享&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {&#xD;&#xA;&#x9;cherrors := make(chan error)&#xD;&#xA;&#x9;wgDone := make(chan bool)&#xD;&#xA;&#xD;&#xA;&#x9;var wg sync.WaitGroup&#xD;&#xA;&#x9;wg.Add(2)&#xD;&#xA;&#x9;go func() {&#xD;&#xA;&#x9;&#x9;//... 业务逻辑&#xD;&#xA;&#x9;&#x9;wg.Done()&#xD;&#xA;&#x9;}()&#xD;&#xA;&#x9;go func() {&#xD;&#xA;&#x9;&#x9;//... 业务逻辑&#xD;&#xA;&#x9;&#x9;err := returnErr()&#xD;&#xA;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;cherrors &amp;lt;- err&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;wg.Done()&#xD;&#xA;&#x9;}()&#xD;&#xA;&#x9;go func() {&#xD;&#xA;&#x9;&#x9;wg.Wait()&#xD;&#xA;&#x9;&#x9;close(wgDone)&#xD;&#xA;&#x9;}()&#xD;&#xA;&#xD;&#xA;&#x9;select {&#xD;&#xA;&#x9;case &amp;lt;-wgDone:&#xD;&#xA;&#x9;&#x9;break&#xD;&#xA;&#x9;case err := &amp;lt;-cherrors:&#xD;&#xA;&#x9;&#x9;close(cherrors)&#xD;&#xA;&#x9;&#x9;fmt.Println(err)&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;time.Sleep(time.Second)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func returnErr() error {&#xD;&#xA;&#x9;return errors.New(&amp;quot;出错啦。。我是错误信息&amp;quot;)&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;使用-syncerrgroup&#34;&gt;使用 &lt;code&gt;sync/errgroup&lt;/code&gt;&lt;/h2&gt;&#xA;&lt;p&gt;使用官方提供的&lt;code&gt;golang.org/x/sync/errgroup&lt;/code&gt;标准库&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 配置私有库</title>
      <link>/post/2022/02/20/28/</link>
      <pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate>
      <guid>/post/2022/02/20/28/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config --global url.&amp;quot;git@git.myscrm.cn:&amp;quot;.insteadOf &amp;quot;https://git.myscrm.cn/&amp;quot;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Golang Defer理解</title>
      <link>/post/2022/01/13/25/</link>
      <pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate>
      <guid>/post/2022/01/13/25/</guid>
      <description>&lt;h3 id=&#34;结论&#34;&gt;结论&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;多个defer的执行顺序为&lt;code&gt;先进后出&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;匿名返回值是在&lt;code&gt;return&lt;/code&gt;执行时被声明，有名返回值则是在函数声明的同时被声明，因此在&lt;code&gt;defer&lt;/code&gt;语句中只能访问有名返回值，而不能直接访问匿名返回值&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;return&lt;/code&gt;其实应该包含前后两个步骤：第一步是给返回值赋值（若为有名返回值则直接赋值，若为匿名返回值则先声明再赋值）；第二步是调用&lt;code&gt;RET&lt;/code&gt;返回指令并传入返回值，而&lt;code&gt;RET&lt;/code&gt;则会检查&lt;code&gt;defer&lt;/code&gt;是否存在，若存在就先逆序插播defer语句，最后RET携带返回值退出函数&lt;/li&gt;&#xA;&lt;li&gt;延迟函数的参数在 defer 语句出现时就已经确定下来了（defer声明时会先计算确定参数的值，defer推迟执行的仅是其函数体）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;解释&#34;&gt;解释&lt;/h3&gt;&#xA;&lt;h5 id=&#34;结论1&#34;&gt;结论1&lt;/h5&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xD;&#xA;&#xD;&#xA;func main() {&#xD;&#xA;    for i := 0; i &amp;lt; 4; i++ {&#xD;&#xA;        defer fmt.Print(i)&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // Output:&#xD;&#xA;    // 3&#xD;&#xA;    // 2&#xD;&#xA;    // 1&#xD;&#xA;    // 0&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h5 id=&#34;结论2和结论3&#34;&gt;结论2和结论3&lt;/h5&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xD;&#xA;&#xD;&#xA;import (&#xD;&#xA;    &amp;quot;fmt&amp;quot;&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;func main() {&#xD;&#xA;    fmt.Println(a())&#xD;&#xA;&#xD;&#xA;    // Output:&#xD;&#xA;    // 1&#xD;&#xA;    // 2&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// 无名返回值&#xD;&#xA;func a() int {&#xD;&#xA;    defer func() { i++ }()&#xD;&#xA;    return 1&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// 有名返回值&#xD;&#xA;func a() (i int) {&#xD;&#xA;    defer func() { i++ }()&#xD;&#xA;    return 1&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h5 id=&#34;结论4&#34;&gt;结论4&lt;/h5&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xD;&#xA;&#xD;&#xA;import (&#xD;&#xA;    &amp;quot;fmt&amp;quot;&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;func main() {&#xD;&#xA;    a()&#xD;&#xA;    b()&#xD;&#xA;&#xD;&#xA;    // Output:&#xD;&#xA;    // 0&#xD;&#xA;    // enter: b&#xD;&#xA;    // in b&#xD;&#xA;    // leave: b&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func a() {&#xD;&#xA;    i := 0&#xD;&#xA;    defer fmt.Println(i) // 调用时i已经确定为0&#xD;&#xA;    i++&#xD;&#xA;    return&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func trace(s string) s {&#xD;&#xA;    fmt.Println(&amp;quot;enter: &amp;quot;, s)&#xD;&#xA;    return s&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func un(s) {&#xD;&#xA;    fmt.Println(&amp;quot;leave: &amp;quot;, s)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func b() {&#xD;&#xA;    defer un(trace(&amp;quot;b&amp;quot;)) // defer声明时会先计算确定参数的值，即执行了trace()，defer推迟执行的仅是其函数体un()&#xD;&#xA;    fmt.Println(&amp;quot;in b&amp;quot;)&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#53-defer&#34;&gt;《Go语言设计与实现》&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1410243&#34;&gt;Golang中defer、return、返回值之间执行顺序的坑&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/huang_yong_peng/article/details/82950743&#34;&gt;理解Golang中defer的使用&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Casbin 理解</title>
      <link>/post/2021/12/31/24/</link>
      <pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/12/31/24/</guid>
      <description>&lt;h3 id=&#34;rbac&#34;&gt;RBAC&lt;/h3&gt;&#xA;&lt;p&gt;model.conf&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;[request_definition]&#xD;&#xA;r = sub, obj, act&#xD;&#xA;&#xD;&#xA;[policy_definition]&#xD;&#xA;p = sub, obj, act&#xD;&#xA;&#xD;&#xA;[role_definition]&#xD;&#xA;g = _, _&#xD;&#xA;&#xD;&#xA;[policy_effect]&#xD;&#xA;e = some(where (p.eft == allow))&#xD;&#xA;&#xD;&#xA;[matchers]&#xD;&#xA;m = g(r.sub, p.sub) &amp;amp;&amp;amp; r.obj == p.obj &amp;amp;&amp;amp; r.act == p.act&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;casbin_rule&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;p, alice, data1, read&#xD;&#xA;p, bob, data2, write&#xD;&#xA;p, data2_admin, data2, read&#xD;&#xA;p, data2_admin, data2, write&#xD;&#xA;&#xD;&#xA;g, alice, data2_admin&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;粗略将&lt;code&gt;sub&lt;/code&gt;可以理解为角色、用户，将&lt;code&gt;obj&lt;/code&gt;理解为资源，将&lt;code&gt;act&lt;/code&gt;理解为操作&#xA;当&lt;code&gt;sub&lt;/code&gt;为用户时，即用户直接对资源进行授权&#xA;当&lt;code&gt;sub&lt;/code&gt;为角色时，即用户分配有某角色，某角色对资源进行授权&lt;/p&gt;&#xA;&lt;p&gt;从上面的例子可以看出&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;alice&lt;/code&gt;被授予了对&lt;code&gt;data1&lt;/code&gt;资源的读权限&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;bob&lt;/code&gt;被授予了对&lt;code&gt;data2&lt;/code&gt;资源的写权限&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;data2_admin&lt;/code&gt;被授予了&lt;code&gt;data2&lt;/code&gt;的读写权限，我们可以把&lt;code&gt;data2_admin&lt;/code&gt;可以理解为角色&lt;/li&gt;&#xA;&lt;li&gt;将&lt;code&gt;alice&lt;/code&gt;分配有&lt;code&gt;data2_admin&lt;/code&gt;角色，则&lt;code&gt;alice&lt;/code&gt;此时具有对&lt;code&gt;data2&lt;/code&gt;的读写权限&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;p：&lt;code&gt;用户、角色&lt;/code&gt;对&lt;code&gt;资源&lt;/code&gt;的授权&#xA;g：将&lt;code&gt;用户&lt;/code&gt;分配有&lt;code&gt;角色&lt;/code&gt;组&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 通过通道控制携程数量</title>
      <link>/post/2021/11/02/23/</link>
      <pubDate>Tue, 02 Nov 2021 17:31:00 +0000</pubDate>
      <guid>/post/2021/11/02/23/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {&#xD;&#xA;&#x9;var wg sync.WaitGroup&#xD;&#xA;&#x9;var ch = make(chan bool, 10)&#xD;&#xA;    for {&#xD;&#xA;        wg.Add(1)&#xD;&#xA;        ch &amp;lt;- true&#xD;&#xA;        go func() {&#xD;&#xA;            defer func() {&#xD;&#xA;                &amp;lt;- ch&#xD;&#xA;                wg.Done()&#xD;&#xA;            }()&#xD;&#xA;            // 逻辑&#xD;&#xA;            ...&#xD;&#xA;        }()&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    wg.Wait()&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Linux 安装 Golang</title>
      <link>/post/2021/06/09/17/</link>
      <pubDate>Wed, 09 Jun 2021 17:41:00 +0000</pubDate>
      <guid>/post/2021/06/09/17/</guid>
      <description>&lt;h3 id=&#34;场景&#34;&gt;场景&lt;/h3&gt;&#xA;&lt;p&gt;使用&lt;code&gt;yum&lt;/code&gt;或&lt;code&gt;apt-get&lt;/code&gt;命令安装，版本不好控制，使用源码安装&lt;/p&gt;&#xA;&lt;h3 id=&#34;源码安装&#34;&gt;源码安装&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查看&lt;code&gt;https://studygolang.com/dl&lt;/code&gt;所需安装版本的地址&#xA;&lt;a href=&#34;https://imgtu.com/i/2RP9Ug&#34;&gt;&lt;img src=&#34;https://z3.ax1x.com/2021/06/10/2RP9Ug.png&#34; alt=&#34;2RP9Ug.png&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;下载&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wget https://studygolang.com/dl/golang/go1.15.13.linux-amd64.tar.gz&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解压&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar -zxvf go1.15.13.linux-amd64.tar.gz&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;移动&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mv go /usr/local/go&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;添加环境变量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 打开&#xD;&#xA;vim /etc/profile&#xD;&#xA;# 添加&#xD;&#xA;export GOROOT=/usr/local/go&#xD;&#xA;export PATH=$PATH:$GOROOT/bin&#xD;&#xA;# 运行&#xD;&#xA;source /etc/profile&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;安装完成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看安装的go版本，校验通过，安装成功&#xD;&#xA;go version&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Golang AES-128/GCM &#43; BASE64 加密</title>
      <link>/post/2021/03/15/14/</link>
      <pubDate>Mon, 15 Mar 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/03/15/14/</guid>
      <description>&lt;p&gt;需求背景：接入网络游戏防沉迷系统，其中请求体body需要进行加密，和签名&lt;/p&gt;&#xA;&lt;h4 id=&#34;加密&#34;&gt;加密&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func GCMEncrypt(secretKey, originalText string) (string, error) {&#xD;&#xA;&#x9;// 密钥需要解码&#xD;&#xA;&#x9;key, _ := hex.DecodeString(secretKey)&#xD;&#xA;&#x9;block, err := aes.NewCipher(key)&#xD;&#xA;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, err&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;aesGcm, err := cipher.NewGCM(block)&#xD;&#xA;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, err&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;// 向量&#xD;&#xA;&#x9;nonce := make([]byte, aesGcm.NonceSize())&#xD;&#xA;&#x9;if _, err := io.ReadFull(rand.Reader, nonce); err != nil {&#xD;&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, err&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;cipherText := aesGcm.Seal(nonce, nonce, []byte(originalText), nil)&#xD;&#xA;&#xD;&#xA;&#x9;// encode as base64 string&#xD;&#xA;&#x9;encoded := base64.StdEncoding.EncodeToString(cipherText)&#xD;&#xA;&#x9;return encoded, nil&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;签名&#34;&gt;签名&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (s *encryptService) Sign(headers, body map[string]string) string {&#xD;&#xA;&#x9;var data string&#xD;&#xA;&#x9;var keys []string&#xD;&#xA;&#x9;// key排序&#xD;&#xA;&#x9;for k := range headers {&#xD;&#xA;&#x9;&#x9;keys = append(keys, k)&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;sort.Strings(keys)&#xD;&#xA;&#xD;&#xA;&#x9;// 拼接&#xD;&#xA;&#x9;for _, k := range keys {&#xD;&#xA;&#x9;&#x9;data = data + k + headers[k]&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;data = s.appSecret + data + gconv.String(body)&#xD;&#xA;&#xD;&#xA;&#x9;// 对字符串进行sha256哈希&#xD;&#xA;&#x9;h := sha256.New()&#xD;&#xA;&#x9;h.Write([]byte(data))&#xD;&#xA;&#x9;sum := h.Sum(nil)&#xD;&#xA;&#x9;return hex.EncodeToString(sum)&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 参数初始化&#xD;&#xA;headers := map[string]string{&#xD;&#xA;&#x9;&amp;quot;appId&amp;quot;:      &amp;quot;xxxxxxxx&amp;quot;,&#xD;&#xA;&#x9;&amp;quot;bizId&amp;quot;:      &amp;quot;xxxxxxxx&amp;quot;,&#xD;&#xA;&#x9;&amp;quot;timestamps&amp;quot;: strconv.Itoa(int(time.Now().UnixNano() / 1e6)),&#xD;&#xA;}&#xD;&#xA;// 请求体加密&#xD;&#xA;jsonByte, _ := json.Marshal(req)&#xD;&#xA;cipher, _ := GCMEncrypt(string(jsonByte), &#39;xxxxxxxxx&#39;) // 第二个参数是密钥&#xD;&#xA;body := map[string]string{&#xD;&#xA;&#x9;&amp;quot;data&amp;quot;: cipher,&#xD;&#xA;}&#xD;&#xA;// 生成签名&#xD;&#xA;headers[&amp;quot;sign&amp;quot;] = Encrypt.Sign(headers, body)&#xD;&#xA;headers[&amp;quot;Content-Type&amp;quot;] = &amp;quot;application/json&amp;quot;&#xD;&#xA;.....发http请求&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
