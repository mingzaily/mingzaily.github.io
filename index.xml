<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on 星河</title>
    <link>/</link>
    <description>Recent content in Home on 星河</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 25 May 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>统一管理 Protocol Buffer，API 大仓设计与实现</title>
      <link>/post/2024/05/25/59/</link>
      <pubDate>Sat, 25 May 2024 00:00:00 +0000</pubDate>
      <guid>/post/2024/05/25/59/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;&#xA;&lt;p&gt;目前公司采用 protocol buffer 作为 IDL，虽然可以根据 API 定义，轻松生成客户端和服务端的代码。但是对于跨项目的接口，会增加项目之间的耦合性。例如 A 服务对外提供了一个接口，B 服务去调用。那么就需要根据 A 服务的 proto 文件，生成客户端代码，并拷贝给 B。如果联调期间，A 服务改动了该接口，还需重复前面的步骤，非常繁琐&lt;/p&gt;&#xA;&lt;h2 id=&#34;方案&#34;&gt;方案&lt;/h2&gt;&#xA;&lt;p&gt;常见的几种解决方案，煎鱼大佬已经描述得很详细了（&lt;a href=&#34;https://mp.weixin.qq.com/s/cBXZjg_R8MLFDJyFtpjVVQ&#34;&gt;真是头疼，Proto 代码到底放哪里？&lt;/a&gt;）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;方案一：api 大仓 + git submodule（b 站）&lt;/li&gt;&#xA;&lt;li&gt;方案二：api 大仓 + git submodule + 每个项目生成代码专有仓库&lt;/li&gt;&#xA;&lt;li&gt;方案三：每个项目都有一个 api 仓库，包含生成的代码&lt;/li&gt;&#xA;&lt;li&gt;方案四：api 大仓 + api 生成代码的集中仓库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;具体方案的优缺点 yuyy 博主已经写清楚了。&#xA;权衡了下，和博主一样选择方案四。&lt;/p&gt;&#xA;&lt;h2 id=&#34;具体实现&#34;&gt;具体实现&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://imgse.com/i/pklP974&#34;&gt;&lt;img src=&#34;https://s21.ax1x.com/2024/05/25/pklP974.png&#34; alt=&#34;pklP974.png&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;drone-文件&#34;&gt;DRONE 文件&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ tree -L 1&#xD;&#xA;.&#xD;&#xA;├── Dockerfile&#xD;&#xA;├── Makefile&#xD;&#xA;├── README.md&#xD;&#xA;├── apis-go.gen.yml&#xD;&#xA;├── apis-go.sh&#xD;&#xA;├── apis-swagger.gen.yml&#xD;&#xA;├── apis-swagger.sh&#xD;&#xA;├── auth-center&#xD;&#xA;├── budget-center&#xD;&#xA;├── common&#xD;&#xA;├── consume-order&#xD;&#xA;├── consume-quota-center&#xD;&#xA;├── consume-rule-to-third&#xD;&#xA;├── datacenter&#xD;&#xA;├── fino-multi-env-center&#xD;&#xA;├── finobase&#xD;&#xA;├── finoconsume&#xD;&#xA;├── invoice&#xD;&#xA;├── mng-center&#xD;&#xA;├── mq-center&#xD;&#xA;├── notify-center&#xD;&#xA;├── org-arch-center&#xD;&#xA;├── org-asset-center&#xD;&#xA;├── org-order-center&#xD;&#xA;├── org-recharge-center&#xD;&#xA;├── org-settle-center&#xD;&#xA;├── pubsvc&#xD;&#xA;├── pushcenter&#xD;&#xA;├── right-recharge&#xD;&#xA;├── snowflake&#xD;&#xA;├── task-center&#xD;&#xA;├── third-consume-order&#xD;&#xA;└── timer&#xD;&#xA;&#xD;&#xA;26 directories, 7 files&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;droneyaml&#34;&gt;.drone.yaml&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;kind: pipeline&#xD;&#xA;type: docker&#xD;&#xA;name: apis&#xD;&#xA;&#xD;&#xA;workspace:&#xD;&#xA;  base: /app&#xD;&#xA;  path: ${DRONE_REPO_NAME}&#xD;&#xA;&#xD;&#xA;steps:&#xD;&#xA;  - name: 检查proto文件&#xD;&#xA;    image: reg.xxxx.com/golang/apis-generate-go:1.0.0&#xD;&#xA;    pull: if-not-exists&#xD;&#xA;    volumes:&#xD;&#xA;      - name: buf-cache&#xD;&#xA;        path: /app/buf/.cache&#xD;&#xA;    commands:&#xD;&#xA;      - buf lint&#xD;&#xA;&#xD;&#xA;  - name: 编译proto文件&#xD;&#xA;    image: reg.xxxx.com/golang/apis-generate-go:1.0.0&#xD;&#xA;    pull: if-not-exists&#xD;&#xA;    volumes:&#xD;&#xA;      - name: buf-cache&#xD;&#xA;        path: /app/buf/.cache&#xD;&#xA;    environment:&#xD;&#xA;      BUF_CACHE_DIR: /app/buf/.cache&#xD;&#xA;      TARGET_REPO: apis-go&#xD;&#xA;      TARGET_REPO_ADDR: git@gogs.xxxx.com:fino/apis-go.git&#xD;&#xA;      SSH_PRIVATE_KEY:&#xD;&#xA;        from_secret: ssh_private_key&#xD;&#xA;    commands:&#xD;&#xA;      - sh ./apis-go.sh&#xD;&#xA;&#xD;&#xA;  - name: 生成swagger文件&#xD;&#xA;    image: reg.xxxx.com/golang/apis-generate-go:1.0.0&#xD;&#xA;    pull: if-not-exists&#xD;&#xA;    volumes:&#xD;&#xA;      - name: buf-cache&#xD;&#xA;        path: /app/buf/.cache&#xD;&#xA;    environment:&#xD;&#xA;      BUF_CACHE_DIR: /app/buf/.cache&#xD;&#xA;      TARGET_REPO: apis-swagger&#xD;&#xA;      TARGET_REPO_ADDR: git@gogs.xxxx.com:fino/apis-swagger.git&#xD;&#xA;      SSH_PRIVATE_KEY:&#xD;&#xA;        from_secret: ssh_private_key&#xD;&#xA;    commands:&#xD;&#xA;      - sh ./apis-swagger.sh&#xD;&#xA;&#xD;&#xA;  - name: 通知&#xD;&#xA;    image: plugins/webhook&#xD;&#xA;    pull: if-not-exists&#xD;&#xA;    settings:&#xD;&#xA;      urls: https://oapi.dingtalk.com/robot/send?access_token=xxxx&#xD;&#xA;      content_type: application/json&#xD;&#xA;      template: |&#xD;&#xA;        {&#xD;&#xA;            &amp;quot;msgtype&amp;quot;: &amp;quot;text&amp;quot;,&#xD;&#xA;            &amp;quot;text&amp;quot;: {&#xD;&#xA;                &amp;quot;content&amp;quot;: &amp;quot;Proto \n &amp;gt; 构建结果: {{ build.status }} \n &amp;gt; 代码分支: {{ build.branch }} \n &amp;gt; 编译详情: {{ build.link }} \n &amp;gt; 提交信息: {{ build.message }} \n &amp;gt; 提交发起: {{ build.author }} &amp;quot;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;volumes: # 定义流水线挂载目录，用于共享数据&#xD;&#xA;  - name: buf-cache&#xD;&#xA;    host:&#xD;&#xA;      path: /home/docker/drone/buf/.cache # 从宿主机中挂载的目录&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;ssh_private_key&lt;/code&gt; 经过&lt;code&gt;echo &#39;私钥文件&#39; | base64&lt;/code&gt;生成，并配置在 DRONE 的 Secrets 上&#xA;&lt;code&gt;buf-cache&lt;/code&gt; 是 drone 挂载硬盘，设置 buf 缓存，加快构建速度&#xA;&lt;code&gt;reg.xxxx.com/golang/apis-generate-go:1.0.0&lt;/code&gt; 封装的一个包含 buf 命令的镜像&lt;/p&gt;</description>
    </item>
    <item>
      <title>Mac 配置 zsh</title>
      <link>/post/2024/02/05/54/</link>
      <pubDate>Mon, 05 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/post/2024/02/05/54/</guid>
      <description>&lt;h2 id=&#34;1-使用-zsh-作为默认-shell&#34;&gt;1. 使用 zsh 作为默认 shell&lt;/h2&gt;&#xA;&lt;p&gt;从 macOS Catalina 版开始，您的 Mac 将使用 zsh 作为默认登录 Shell 和交互式 Shell。您还可以在较低版本的 macOS 中将 zsh 设置为默认 Shell。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;chsh -s /bin/zsh&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;参看：&lt;a href=&#34;https://support.apple.com/zh-cn/HT208050&#34;&gt;在 Mac 上将 zsh 用作默认 Shell&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;2-安装-oh-my-zsh&#34;&gt;2. 安装 oh-my-zsh&lt;/h2&gt;&#xA;&lt;h3 id=&#34;自动安装&#34;&gt;自动安装&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;也可以手动安装：&lt;/p&gt;&#xA;&lt;h3 id=&#34;手动安装&#34;&gt;手动安装&lt;/h3&gt;&#xA;&lt;p&gt;下载 oh-my-zsh&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone --depth=1 https://github.com/ohmyzsh/ohmyzsh.git ~/.oh-my-zsh&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;备份原有 ~/.zshrc（如果有）&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp ~/.zshrc ~/.zshrc.bak&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;从模板创建 zsh 配置文件&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;3-更改-zsh-主题&#34;&gt;3. 更改 zsh 主题&lt;/h2&gt;&#xA;&lt;p&gt;主题样式 &lt;a href=&#34;https://github.com/ohmyzsh/ohmyzsh/wiki/Themes&#34;&gt;这里&lt;/a&gt; 查看。&lt;/p&gt;</description>
    </item>
    <item>
      <title>RSA 加解密</title>
      <link>/post/2024/02/05/55/</link>
      <pubDate>Mon, 05 Feb 2024 00:00:00 +0000</pubDate>
      <guid>/post/2024/02/05/55/</guid>
      <description>&lt;h2 id=&#34;rsa-加密简介&#34;&gt;RSA 加密简介&lt;/h2&gt;&#xA;&lt;p&gt;RSA 加密是一种非对称加密。可以在不直接传递密钥的情况下，完成解密。这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。是由一对密钥来进行加解密的过程，分别称为公钥和私钥。两者之间有数学相关，该加密算法的原理就是对一极大整数做因数分解的困难性来保证安全性。通常个人保存私钥，公钥是公开的（可能同时多人持有）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;rsa-加密签名区别&#34;&gt;RSA 加密、签名区别&lt;/h2&gt;&#xA;&lt;p&gt;加密和签名都是为了安全性考虑，但略有不同。常有人问加密和签名是用私钥还是公钥？其实都是对加密和签名的作用有所混淆。简单的说，加密是为了防止信息被泄露，而签名是为了防止信息被篡改。这里举 2 个例子说明。&lt;/p&gt;&#xA;&lt;h4 id=&#34;第一个场景战场上b-要给-a-传递一条消息内容为某一指令&#34;&gt;第一个场景：战场上，B 要给 A 传递一条消息，内容为某一指令。&lt;/h4&gt;&#xA;&lt;p&gt;RSA 的加密过程如下：&lt;/p&gt;&#xA;&lt;p&gt;（1）A 生成一对密钥（公钥和私钥），私钥不公开，A 自己保留。公钥为公开的，任何人可以获取。&lt;/p&gt;&#xA;&lt;p&gt;（2）A 传递自己的公钥给 B，B 用 A 的公钥对消息进行加密。&lt;/p&gt;&#xA;&lt;p&gt;（3）A 接收到 B 加密的消息，利用 A 自己的私钥对消息进行解密。&lt;/p&gt;&#xA;&lt;p&gt;在这个过程中，只有 2 次传递过程，第一次是 A 传递公钥给 B，第二次是 B 传递加密消息给 A，即使都被敌方截获，也没有危险性，因为只有 A 的私钥才能对消息进行解密，防止了消息内容的泄露。&lt;/p&gt;&#xA;&lt;h4 id=&#34;第二个场景a-收到-b-发的消息后需要进行回复收到&#34;&gt;第二个场景：A 收到 B 发的消息后，需要进行回复“收到”。&lt;/h4&gt;&#xA;&lt;p&gt;RSA 签名的过程如下：&lt;/p&gt;&#xA;&lt;p&gt;（1）A 生成一对密钥（公钥和私钥），私钥不公开，A 自己保留。公钥为公开的，任何人可以获取。&lt;/p&gt;&#xA;&lt;p&gt;（2）A 用自己的私钥对消息加签，形成签名，并将加签的消息和消息本身一起传递给 B。&lt;/p&gt;&#xA;&lt;p&gt;（3）B 收到消息后，在获取 A 的公钥进行验签，如果验签出来的内容与消息本身一致，证明消息是 A 回复的。&lt;/p&gt;&#xA;&lt;p&gt;在这个过程中，只有 2 次传递过程，第一次是 A 传递加签的消息和消息本身给 B，第二次是 B 获取 A 的公钥，即使都被敌方截获，也没有危险性，因为只有 A 的私钥才能对消息进行签名，即使知道了消息内容，也无法伪造带签名的回复给 B，防止了消息内容的篡改。&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于敏感数据加密的设计</title>
      <link>/post/2023/08/31/49/</link>
      <pubDate>Thu, 31 Aug 2023 00:00:00 +0000</pubDate>
      <guid>/post/2023/08/31/49/</guid>
      <description>&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查询用 hash ，使用用加密。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;cellphone_enc, cellphone_hash, id_enc,id_hash. 如果还要查询归属地的，再加一个 phone_meta 里面只存前 7 位即可&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;加密后如何查询才能击中索引；&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;使用 hash 查询。&#xA;加密字段只允许精准查询，不允许模糊。&#xA;如果一定要模糊，那也是有限制的模糊，提前定好模糊规则，根据模糊规则提前预留相关数据，再进行加密。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;用户身份如何验证（手机号、身份证）；&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;验证后再加密，或者允许解密。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;所以你需要&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一个专用于加密解密的服务。&#xA;所有加密解密都访问该服务。&#xA;可访问数据库的人，秘钥管理人，加密服务管理人，这三方不能有任何一方有办法获取到所有要素。&lt;/li&gt;&#xA;&lt;li&gt;调用解密必须有日志。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;注意：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;不同业务场景对脱敏的要求是不一样的。我们公司的要求是，任何人任何时候都不能看到明文，明文只出现在内存中。&#xA;有时候，脱敏并不是要求看不到明文，而是要求 不要让人在看到 1 条明文时，再看到与之相关的其他明文，进而推测出业务信息，例如同时看到姓名与手机号。当然，这与你们公司的具体场景有关。&lt;/li&gt;&#xA;&lt;li&gt;解密后，明文在内存中，如果被 log ，一直面临风险，所以需要对日志进行审核。&lt;/li&gt;&#xA;&lt;li&gt;现在有些数据库或者数据库中间件支持字段脱敏。你可以参考他们的方案。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Go 面试题目</title>
      <link>/post/2023/03/15/44/</link>
      <pubDate>Wed, 15 Mar 2023 00:00:00 +0000</pubDate>
      <guid>/post/2023/03/15/44/</guid>
      <description>&lt;ol&gt;&#xA;&lt;li&gt;slice 底层原理、扩容机制&lt;/li&gt;&#xA;&lt;li&gt;map 底层原理、扩容机制&lt;/li&gt;&#xA;&lt;li&gt;channel 底层原理 环形缓存+双队列&lt;/li&gt;&#xA;&lt;li&gt;context 原理、应用场景&lt;/li&gt;&#xA;&lt;li&gt;GMP模型&lt;/li&gt;&#xA;&lt;li&gt;GC策略&lt;/li&gt;&#xA;&lt;li&gt;new 和 make 的区别&lt;/li&gt;&#xA;&lt;li&gt;map 如何知道自己处于竞争状态&lt;/li&gt;&#xA;&lt;li&gt;defer、recover、panic 实现原理&lt;/li&gt;&#xA;&lt;li&gt;二叉树 树的遍历 前中后序遍历、深度和广度&lt;/li&gt;&#xA;&lt;li&gt;平衡二叉树 左旋转、右旋转&lt;/li&gt;&#xA;&lt;li&gt;分布式一致性 ACID、CAP、BASE理论推荐&lt;/li&gt;&#xA;&lt;li&gt;Mysql 分库分表方式&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Golang 简易WS服务 - 客户端</title>
      <link>/post/2023/02/21/42/</link>
      <pubDate>Tue, 21 Feb 2023 00:00:00 +0000</pubDate>
      <guid>/post/2023/02/21/42/</guid>
      <description>&lt;p&gt;客户端代码较为简单&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;&#xD;&#xA;type SocketClient struct {&#xD;&#xA;&#x9;host        string&#xD;&#xA;&#x9;isClosed    chan bool&#xD;&#xA;&#x9;log         *logger.Log // 自定义的log包&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;type wsMessage struct {&#xD;&#xA;&#x9;Type int         `json:&amp;quot;type&amp;quot;`&#xD;&#xA;&#x9;Data interface{} `json:&amp;quot;data&amp;quot;`&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func NewSocketClient(configPath, logPath, host string) *SocketClient {&#xD;&#xA;&#x9;w := io.MultiWriter(os.Stdout)&#xD;&#xA;&#x9;if logPath != &amp;quot;&amp;quot; {&#xD;&#xA;&#x9;&#x9;f, err := util.OpenFile(logPath)&#xD;&#xA;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;panic(err)&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;w = io.MultiWriter(os.Stdout, f)&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;return &amp;amp;SocketClient{&#xD;&#xA;&#x9;&#x9;host:        host,&#xD;&#xA;&#x9;&#x9;isClosed:    make(chan bool),&#xD;&#xA;&#x9;&#x9;log:         logger.New(w, logger.LINFO, log.LstdFlags|log.Lmsgprefix),&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func (s *SocketClient) Start() {&#xD;&#xA;&#x9;// 设置在线&#xD;&#xA;&#x9;ClientStatus = ClientStatusOnline&#xD;&#xA;&#xD;&#xA;&#x9;// 连接服务器&#xD;&#xA;&#x9;u := url.URL{Scheme: &amp;quot;ws&amp;quot;, Host: s.host, Path: &amp;quot;/socket&amp;quot;}&#xD;&#xA;&#x9;s.log.Info(&amp;quot;正在连接到&amp;quot;, u.String())&#xD;&#xA;&#xD;&#xA;&#x9;conn, _, err := websocket.DefaultDialer.Dial(u.String(), nil)&#xD;&#xA;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;s.log.ErrorF(&amp;quot;连接到服务器错误: %v&amp;quot;, err)&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;defer conn.Close()&#xD;&#xA;&#xD;&#xA;&#x9;s.log.Info(&amp;quot;已连接到服务器&amp;quot;)&#xD;&#xA;&#xD;&#xA;&#x9;interrupt := make(chan os.Signal, 1)&#xD;&#xA;&#xD;&#xA;&#x9;// 监听中断信号&#xD;&#xA;&#x9;signal.Notify(interrupt, syscall.SIGKILL, syscall.SIGINT, syscall.SIGTERM, os.Kill)&#xD;&#xA;&#x9;// 心跳包&#xD;&#xA;&#x9;go s.pingHandler(conn)&#xD;&#xA;&#x9;// 接收消息&#xD;&#xA;&#x9;go s.receiveHandler(conn)&#xD;&#xA;&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;case &amp;lt;-interrupt:&#xD;&#xA;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;收到SIGINT中断信号，正在关闭ws连接。。。&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;_ = conn.WriteControl(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, &amp;quot;&amp;quot;), time.Now().Add(time.Second))&#xD;&#xA;&#x9;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;&#x9;case &amp;lt;-s.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;WS链接已关闭，退出中。。。&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;case &amp;lt;-time.After(time.Duration(1) * time.Second):&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;关闭ws链接超时，退出中。。。&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;case &amp;lt;-s.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;ws链接已关闭，退出中。。。&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func (s *SocketClient) pingHandler(conn *websocket.Conn) {&#xD;&#xA;&#x9;ticker := time.NewTicker(pingTime)&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;case &amp;lt;-ticker.C:&#xD;&#xA;&#x9;&#x9;&#x9;status := strconv.FormatInt(int64(ClientStatus), 10)&#xD;&#xA;&#x9;&#x9;&#x9;err := conn.WriteMessage(websocket.PingMessage, []byte(status))&#xD;&#xA;&#x9;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;s.log.ErrorF(&amp;quot;发送心跳包错误: %v&amp;quot;, err)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;case &amp;lt;-s.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func (s *SocketClient) receiveHandler(ws *websocket.Conn) {&#xD;&#xA;&#x9;defer close(s.isClosed)&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;messageType, message, err := ws.ReadMessage()&#xD;&#xA;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;s.log.ErrorF(&amp;quot;读取消息 %v&amp;quot;, err)&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;switch messageType {&#xD;&#xA;&#x9;&#x9;case websocket.TextMessage:&#xD;&#xA;&#x9;&#x9;&#x9;var textMessage *wsMessage&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;&#x9;err = json.Unmarshal(message, &amp;amp;textMessage)&#xD;&#xA;&#x9;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;s.log.ErrorF(&amp;quot;消息格式错误: %v&amp;quot;, err)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;&#x9;switch textMessage.Type {&#xD;&#xA;&#x9;&#x9;&#x9;        ...&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Golang 简易WS服务 - 服务端</title>
      <link>/post/2023/02/21/39/</link>
      <pubDate>Tue, 21 Feb 2023 00:00:00 +0000</pubDate>
      <guid>/post/2023/02/21/39/</guid>
      <description>&lt;h2 id=&#34;本次开发主要使用了gorilla-websocket软件包&#34;&gt;本次开发主要使用了Gorilla Websocket软件包&lt;/h2&gt;&#xA;&lt;h3 id=&#34;客户端结构体&#34;&gt;客户端结构体&lt;/h3&gt;&#xA;&lt;p&gt;维护socket连接，保存客户端信息&lt;/p&gt;&#xA;&lt;h4 id=&#34;代码&#34;&gt;代码&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package contorller&#xD;&#xA;&#xD;&#xA;import (&#xD;&#xA;&#x9;&amp;quot;encoding/json&amp;quot;&#xD;&#xA;&#x9;&amp;quot;fmt&amp;quot;&#xD;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/model&amp;quot;&#xD;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/enum&amp;quot;&#xD;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/logger&amp;quot;&#xD;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/response&amp;quot;&#xD;&#xA;&#x9;&amp;quot;github.com/gorilla/websocket&amp;quot;&#xD;&#xA;&#x9;&amp;quot;strconv&amp;quot;&#xD;&#xA;&#x9;&amp;quot;time&amp;quot;&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;const (&#xD;&#xA;&#x9;// pingWait is the maximum time in seconds to wait for a ping from&#xD;&#xA;&#x9;pingWait = 20 * time.Second&#xD;&#xA;&#x9;// Maximum message size allowed from peer.&#xD;&#xA;&#x9;maxMessageSize = 512&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;type wsClient struct {&#xD;&#xA;&#x9;manager  *wsManager&#xD;&#xA;&#x9;id       string&#xD;&#xA;&#x9;desc     string&#xD;&#xA;&#x9;conn     *websocket.Conn&#xD;&#xA;&#x9;status   enum.ClientStatus&#xD;&#xA;&#x9;send     chan []byte&#xD;&#xA;&#x9;isClosed chan bool&#xD;&#xA;&#x9;lastPing time.Time&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func newWsClient(manager *wsManager, conn *websocket.Conn, id, name, ip string) *wsClient {&#xD;&#xA;&#x9;return &amp;amp;wsClient{&#xD;&#xA;&#x9;&#x9;manager:  manager,&#xD;&#xA;&#x9;&#x9;id:       id,&#xD;&#xA;&#x9;&#x9;desc:     fmt.Sprintf(&amp;quot;客户端(%s, %s)&amp;quot;, name, ip),&#xD;&#xA;&#x9;&#x9;conn:     conn,&#xD;&#xA;&#x9;&#x9;status:   enum.ClientStatusOffline,&#xD;&#xA;&#x9;&#x9;send:     make(chan []byte),&#xD;&#xA;&#x9;&#x9;isClosed: make(chan bool),&#xD;&#xA;&#x9;&#x9;lastPing: time.Now(),&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// Read 读取客户端发送过来的消息&#xD;&#xA;func (c *wsClient) Read() {&#xD;&#xA;&#x9;defer func() {&#xD;&#xA;&#x9;&#x9;c.unRegister()&#xD;&#xA;&#x9;&#x9;logger.Info(c.desc, &amp;quot;read协程退出&amp;quot;)&#xD;&#xA;&#x9;}()&#xD;&#xA;&#xD;&#xA;&#x9;c.conn.SetReadLimit(maxMessageSize)&#xD;&#xA;&#x9;c.conn.SetPingHandler(func(text string) error {&#xD;&#xA;&#x9;&#x9;// 只需要知道客户端还活着就行，不需要回复&#xD;&#xA;&#x9;&#x9;c.lastPing = time.Now()&#xD;&#xA;&#x9;&#x9;// 更新客户端状态&#xD;&#xA;&#x9;&#x9;clientStatus, _ := strconv.ParseInt(text, 10, 32)&#xD;&#xA;&#x9;&#x9;c.status = enum.ClientStatus(int32(clientStatus))&#xD;&#xA;&#x9;&#x9;return nil&#xD;&#xA;&#x9;})&#xD;&#xA;&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;msgType, data, err := c.conn.ReadMessage()&#xD;&#xA;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;logger.Error(c.desc, &amp;quot;c.conn.ReadMessage&amp;quot;, err.Error())&#xD;&#xA;&#x9;&#x9;&#x9;break&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;switch msgType {&#xD;&#xA;&#x9;&#x9;case websocket.TextMessage:&#xD;&#xA;&#x9;&#x9;&#x9;var msg *model.WsMessage&#xD;&#xA;&#x9;&#x9;&#x9;err = json.Unmarshal(data, &amp;amp;msg)&#xD;&#xA;&#x9;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;logger.Error(c.desc, &amp;quot;json.Unmarshal&amp;quot;, err.Error())&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;&#x9;switch msg.Type {&#xD;&#xA;&#x9;&#x9;&#x9;default:&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;logger.Info(c.desc, &amp;quot;未知消息类型&amp;quot;, string(data))&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;c.send &amp;lt;- data&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// Write 把对应消息写回客户端&#xD;&#xA;func (c *wsClient) Write() {&#xD;&#xA;&#x9;defer func() {&#xD;&#xA;&#x9;&#x9;logger.Info(c.desc, &amp;quot;write协程退出&amp;quot;)&#xD;&#xA;&#x9;&#x9;c.unRegister()&#xD;&#xA;&#x9;}()&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;case &amp;lt;-c.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;case msg := &amp;lt;-c.send:&#xD;&#xA;&#x9;&#x9;&#x9;err := c.conn.WriteMessage(websocket.TextMessage, msg)&#xD;&#xA;&#x9;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;logger.Error(c.desc, &amp;quot;c.conn.WriteMessage&amp;quot;, err.Error())&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// Check 检测客户端是否超时&#xD;&#xA;func (c *wsClient) Check() {&#xD;&#xA;&#x9;defer func() {&#xD;&#xA;&#x9;&#x9;logger.Info(c.desc, &amp;quot;check协程退出&amp;quot;)&#xD;&#xA;&#x9;}()&#xD;&#xA;&#x9;ticker := time.NewTicker(pingWait / 6)&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;case &amp;lt;-c.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;case &amp;lt;-ticker.C:&#xD;&#xA;&#x9;&#x9;&#x9;// 主动关闭连接&#xD;&#xA;&#x9;&#x9;&#x9;if time.Now().Sub(c.lastPing) &amp;gt; pingWait {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;response.WsReturnErr(c.conn, enum.WsDataErr, &amp;quot;客户端超时，主动关闭连接&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;logger.Info(c.desc, &amp;quot;客户端超时，主动关闭连接&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func (c *wsClient) unRegister() {&#xD;&#xA;&#x9;if c.manager.clients[c.id] != nil {&#xD;&#xA;&#x9;&#x9;c.manager.unRegister &amp;lt;- c&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;&#xA;&lt;p&gt;应当在控制器/入口处&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 协程更好的进行错误处理</title>
      <link>/post/2022/06/02/29/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      <guid>/post/2022/06/02/29/</guid>
      <description>&lt;h2 id=&#34;利用-channel-来传输多个-goroutine-中的-errors&#34;&gt;利用 &lt;code&gt;channel&lt;/code&gt; 来传输多个 goroutine 中的 errors&lt;/h2&gt;&#xA;&lt;p&gt;Go 的经典哲学：不要通过共享内存来通信，而是通过通信来实现内存共享&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {&#xD;&#xA;&#x9;cherrors := make(chan error)&#xD;&#xA;&#x9;wgDone := make(chan bool)&#xD;&#xA;&#xD;&#xA;&#x9;var wg sync.WaitGroup&#xD;&#xA;&#x9;wg.Add(2)&#xD;&#xA;&#x9;go func() {&#xD;&#xA;&#x9;&#x9;//... 业务逻辑&#xD;&#xA;&#x9;&#x9;wg.Done()&#xD;&#xA;&#x9;}()&#xD;&#xA;&#x9;go func() {&#xD;&#xA;&#x9;&#x9;//... 业务逻辑&#xD;&#xA;&#x9;&#x9;err := returnErr()&#xD;&#xA;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;cherrors &amp;lt;- err&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;wg.Done()&#xD;&#xA;&#x9;}()&#xD;&#xA;&#x9;go func() {&#xD;&#xA;&#x9;&#x9;wg.Wait()&#xD;&#xA;&#x9;&#x9;close(wgDone)&#xD;&#xA;&#x9;}()&#xD;&#xA;&#xD;&#xA;&#x9;select {&#xD;&#xA;&#x9;case &amp;lt;-wgDone:&#xD;&#xA;&#x9;&#x9;break&#xD;&#xA;&#x9;case err := &amp;lt;-cherrors:&#xD;&#xA;&#x9;&#x9;close(cherrors)&#xD;&#xA;&#x9;&#x9;fmt.Println(err)&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;time.Sleep(time.Second)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func returnErr() error {&#xD;&#xA;&#x9;return errors.New(&amp;quot;出错啦。。我是错误信息&amp;quot;)&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;使用-syncerrgroup&#34;&gt;使用 &lt;code&gt;sync/errgroup&lt;/code&gt;&lt;/h2&gt;&#xA;&lt;p&gt;使用官方提供的&lt;code&gt;golang.org/x/sync/errgroup&lt;/code&gt;标准库&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 配置私有库</title>
      <link>/post/2022/02/20/28/</link>
      <pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate>
      <guid>/post/2022/02/20/28/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git config --global url.&amp;quot;git@git.myscrm.cn:&amp;quot;.insteadOf &amp;quot;https://git.myscrm.cn/&amp;quot;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>SQL提交规范</title>
      <link>/post/2022/02/18/27/</link>
      <pubDate>Fri, 18 Feb 2022 00:00:00 +0000</pubDate>
      <guid>/post/2022/02/18/27/</guid>
      <description>&lt;h4 id=&#34;规范&#34;&gt;规范&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;插入数据不可重复，使用 &lt;code&gt;REPLACE INTO&lt;/code&gt; 替代 &lt;code&gt;INSERT INTO&lt;/code&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;REPLACE INTO tableName(columnName, ...) VALUES(...)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;添加表时，使用 &lt;code&gt;IF NOT EXISTS&lt;/code&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE IF NOT EXISTS XXX&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;删除表时，可以使用 &lt;code&gt;IF EXISTS&lt;/code&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;DROP TABLE IF EXISTS XXX&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;管理字段和索引时，使用存储过程&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CALL AddColumnIfNotExists (&#39;ztc_room&#39;, &#39;introduction&#39;, &#39;VARCHAR(1000) NOT NULL DEFAULT \&#39;\&#39; COMMENT \&#39;房源介绍\&#39;&#39;);&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;常用存储过程&#34;&gt;常用存储过程&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;过程名&lt;/th&gt;&#xA;          &lt;th&gt;含义&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;AddColumnIfNotExists&lt;/td&gt;&#xA;          &lt;td&gt;添加字段（表名，字段名，字段描述）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;UpdateColumnIfExists&lt;/td&gt;&#xA;          &lt;td&gt;更新字段（表名，字段名，字段描述）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;DropColumnIfExists&lt;/td&gt;&#xA;          &lt;td&gt;删除字段（表名，字段名）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CreateIndexIfNotExists&lt;/td&gt;&#xA;          &lt;td&gt;添加普通索引（表名，字段名）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CreateUniqueIndexIfNotExists&lt;/td&gt;&#xA;          &lt;td&gt;添加唯一索引（表名，字段名）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CreateIndexIfNotExistsWithColumns&lt;/td&gt;&#xA;          &lt;td&gt;添加组合普通索引（表名，索引名，字段名）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;CreateUniqueIndexIfNotExistsWithColumns&lt;/td&gt;&#xA;          &lt;td&gt;添加组合唯一索引（表名，索引名，字段名）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;DropIndexIfExists&lt;/td&gt;&#xA;          &lt;td&gt;删除索引（表名，索引名）&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;pre&gt;&lt;code&gt;DELIMITER  $$&#xD;&#xA;# AddColumnIfNotExists 添加字段&#xD;&#xA;DROP&#xD;&#xA;    PROCEDURE IF EXISTS AddColumnIfNotExists$$&#xD;&#xA;CREATE PROCEDURE `AddColumnIfNotExists`(&#xD;&#xA;    IN tableName varchar(100), IN columnName varchar(100),&#xD;&#xA;    IN dbType varchar(100))&#xD;&#xA;BEGIN&#xD;&#xA;    DECLARE _tableCount INT;&#xD;&#xA;    DECLARE _columnCount INT;&#xD;&#xA;&#xD;&#xA;    SET&#xD;&#xA;        _tableCount = (&#xD;&#xA;            SELECT COUNT(1)&#xD;&#xA;            FROM INFORMATION_SCHEMA.TABLES&#xD;&#xA;            WHERE TABLE_SCHEMA = (&#xD;&#xA;                SELECT SCHEMA(&#xD;&#xA;                        )&#xD;&#xA;            )&#xD;&#xA;            AND TABLE_NAME = tableName);&#xD;&#xA;&#xD;&#xA;    SET&#xD;&#xA;        _columnCount = (&#xD;&#xA;            SELECT COUNT(1)&#xD;&#xA;            FROM INFORMATION_SCHEMA.COLUMNS&#xD;&#xA;            WHERE TABLE_SCHEMA = (&#xD;&#xA;                SELECT SCHEMA(&#xD;&#xA;                        )&#xD;&#xA;            )&#xD;&#xA;            AND TABLE_NAME = tableName&#xD;&#xA;            AND COLUMN_NAME = columnName);&#xD;&#xA;    IF _tableCount = 1&#xD;&#xA;        AND _columnCount = 0&#xD;&#xA;    THEN&#xD;&#xA;        SET&#xD;&#xA;            @_sqlText = CONCAT(&#39; ALTER TABLE `&#39;,&#xD;&#xA;                            tableName, &#39;` ADD COLUMN `&#39;,&#xD;&#xA;                            columnName, &#39;` &#39;,&#xD;&#xA;                            dbType);&#xD;&#xA;        PREPARE stmt1&#xD;&#xA;            FROM&#xD;&#xA;            @_sqlText;&#xD;&#xA;        EXECUTE stmt1;&#xD;&#xA;        DEALLOCATE PREPARE stmt1;&#xD;&#xA;    END IF;&#xD;&#xA;END$$&#xD;&#xA;&#xD;&#xA;# UpdateColumnIfExists 更新字段&#xD;&#xA;DROP&#xD;&#xA;    PROCEDURE IF EXISTS UpdateColumnIfExists$$&#xD;&#xA;CREATE PROCEDURE `UpdateColumnIfExists`(&#xD;&#xA;    IN tableName varchar(100), IN columnName varchar(100),&#xD;&#xA;    IN dbType varchar(100))&#xD;&#xA;BEGIN&#xD;&#xA;    DECLARE _columnCount INT;&#xD;&#xA;&#xD;&#xA;    SET&#xD;&#xA;        _columnCount = (&#xD;&#xA;            SELECT COUNT(1)&#xD;&#xA;            FROM INFORMATION_SCHEMA.COLUMNS&#xD;&#xA;            WHERE TABLE_SCHEMA = (&#xD;&#xA;                SELECT SCHEMA(&#xD;&#xA;                        )&#xD;&#xA;            )&#xD;&#xA;            AND TABLE_NAME = tableName&#xD;&#xA;            AND COLUMN_NAME = columnName);&#xD;&#xA;    IF&#xD;&#xA;        _columnCount = 1 THEN&#xD;&#xA;        SET&#xD;&#xA;            @_sqlText = CONCAT(&#39; ALTER TABLE `&#39;,&#xD;&#xA;                            tableName, &#39;` MODIFY COLUMN `&#39;,&#xD;&#xA;                            columnName, &#39;` &#39;,&#xD;&#xA;                            dbType&#xD;&#xA;                );&#xD;&#xA;        PREPARE stmt1&#xD;&#xA;            FROM&#xD;&#xA;            @_sqlText;&#xD;&#xA;        EXECUTE stmt1; DEALLOCATE PREPARE stmt1;&#xD;&#xA;    END IF;&#xD;&#xA;END$$&#xD;&#xA;&#xD;&#xA;# DropColumnIfExists 删除字段&#xD;&#xA;DROP&#xD;&#xA;    PROCEDURE IF EXISTS DropColumnIfExists$$&#xD;&#xA;CREATE PROCEDURE `DropColumnIfExists`(&#xD;&#xA;    IN tableName varchar(100), IN columnName varchar(100))&#xD;&#xA;BEGIN&#xD;&#xA;    DECLARE _columnCount INT;&#xD;&#xA;&#xD;&#xA;    SET&#xD;&#xA;        _columnCount = (&#xD;&#xA;            SELECT COUNT(1)&#xD;&#xA;            FROM INFORMATION_SCHEMA.COLUMNS&#xD;&#xA;            WHERE TABLE_SCHEMA = (&#xD;&#xA;                SELECT SCHEMA(&#xD;&#xA;                        )&#xD;&#xA;            )&#xD;&#xA;            AND TABLE_NAME = tableName&#xD;&#xA;            AND COLUMN_NAME = columnName);&#xD;&#xA;    IF _columnCount = 1&#xD;&#xA;    THEN&#xD;&#xA;        SET&#xD;&#xA;            @_sqlText = CONCAT(&#39; ALTER TABLE &#39;,&#xD;&#xA;                            tableName, &#39; DROP COLUMN &#39;,&#xD;&#xA;                            columnName, &#39; ;&#39;&#xD;&#xA;                );&#xD;&#xA;        PREPARE stmt1&#xD;&#xA;            FROM&#xD;&#xA;            @_sqlText;&#xD;&#xA;        EXECUTE stmt1;&#xD;&#xA;        DEALLOCATE PREPARE stmt1;&#xD;&#xA;    END IF;&#xD;&#xA;END$$&#xD;&#xA;&#xD;&#xA;# CreateIndexIfNotExists 添加普通索引&#xD;&#xA;DROP&#xD;&#xA;    PROCEDURE IF EXISTS CreateIndexIfNotExists$$&#xD;&#xA;CREATE PROCEDURE `CreateIndexIfNotExists`(&#xD;&#xA;    IN tableName varchar(100), IN columnName varchar(100))&#xD;&#xA;BEGIN&#xD;&#xA;    DECLARE _tableCount INT;&#xD;&#xA;    DECLARE _indexCount INT;&#xD;&#xA;&#xD;&#xA;    SET&#xD;&#xA;        _tableCount = (&#xD;&#xA;            SELECT COUNT(1)&#xD;&#xA;            FROM INFORMATION_SCHEMA.TABLES&#xD;&#xA;            WHERE TABLE_SCHEMA = (&#xD;&#xA;                SELECT SCHEMA(&#xD;&#xA;                        )&#xD;&#xA;            )&#xD;&#xA;            AND TABLE_NAME = tableName);&#xD;&#xA;&#xD;&#xA;    SET&#xD;&#xA;        _indexCount = (&#xD;&#xA;            SELECT COUNT(1)&#xD;&#xA;            FROM information_schema.statistics&#xD;&#xA;            WHERE TABLE_SCHEMA = (&#xD;&#xA;                SELECT SCHEMA(&#xD;&#xA;                        )&#xD;&#xA;            )&#xD;&#xA;            AND TABLE_NAME = tableName&#xD;&#xA;            AND INDEX_NAME = CONCAT(&#39;IX_&#39;,&#xD;&#xA;                                    columnName)&#xD;&#xA;        );&#xD;&#xA;    IF _tableCount = 1&#xD;&#xA;        AND _indexCount = 0&#xD;&#xA;    THEN&#xD;&#xA;        SET&#xD;&#xA;            @_sqlText = CONCAT(&#39; CREATE INDEX `IX_&#39;,&#xD;&#xA;                            columnName, &#39;` ON `&#39;,&#xD;&#xA;                            tableName, &#39;`(`&#39;,&#xD;&#xA;                            columnName, &#39;` ASC);&#39;&#xD;&#xA;                );&#xD;&#xA;        PREPARE stmt1&#xD;&#xA;            FROM&#xD;&#xA;            @_sqlText;&#xD;&#xA;        EXECUTE stmt1; DEALLOCATE PREPARE stmt1;&#xD;&#xA;    END IF;&#xD;&#xA;END$$&#xD;&#xA;&#xD;&#xA;# CreateUniqueIndexIfNotExists 添加唯一索引&#xD;&#xA;DROP&#xD;&#xA;    PROCEDURE IF EXISTS CreateUniqueIndexIfNotExists$$&#xD;&#xA;CREATE PROCEDURE `CreateUniqueIndexIfNotExists`(&#xD;&#xA;    IN tableName varchar(100), IN columnName varchar(100))&#xD;&#xA;BEGIN&#xD;&#xA;    DECLARE _tableCount INT;&#xD;&#xA;    DECLARE _indexCount INT;&#xD;&#xA;&#xD;&#xA;    SET&#xD;&#xA;        _tableCount = (&#xD;&#xA;            SELECT COUNT(1)&#xD;&#xA;            FROM INFORMATION_SCHEMA.TABLES&#xD;&#xA;            WHERE TABLE_SCHEMA = (&#xD;&#xA;                SELECT SCHEMA(&#xD;&#xA;                        )&#xD;&#xA;            )&#xD;&#xA;            AND TABLE_NAME = tableName);&#xD;&#xA;&#xD;&#xA;    SET&#xD;&#xA;        _indexCount = (&#xD;&#xA;            SELECT COUNT(1)&#xD;&#xA;            FROM information_schema.statistics&#xD;&#xA;            WHERE TABLE_SCHEMA = (&#xD;&#xA;                SELECT SCHEMA(&#xD;&#xA;                        )&#xD;&#xA;            )&#xD;&#xA;            AND TABLE_NAME = tableName&#xD;&#xA;            AND INDEX_NAME = CONCAT(&#39;IX_&#39;,&#xD;&#xA;                                    columnName)&#xD;&#xA;        );&#xD;&#xA;    IF _tableCount = 1&#xD;&#xA;        AND _indexCount = 0&#xD;&#xA;    THEN&#xD;&#xA;        SET&#xD;&#xA;            @_sqlText = CONCAT(&#39; CREATE UNIQUE INDEX `IX_&#39;,&#xD;&#xA;                            columnName, &#39;` ON `&#39;,&#xD;&#xA;                            tableName, &#39;`(`&#39;,&#xD;&#xA;                            columnName, &#39;` ASC);&#39;&#xD;&#xA;                );&#xD;&#xA;        PREPARE stmt1&#xD;&#xA;            FROM&#xD;&#xA;            @_sqlText;&#xD;&#xA;        EXECUTE stmt1; DEALLOCATE PREPARE stmt1;&#xD;&#xA;    END IF;&#xD;&#xA;END$$&#xD;&#xA;&#xD;&#xA;# CreateIndexIfNotExistsWithColumns 添加组合普通索引&#xD;&#xA;DROP&#xD;&#xA;    PROCEDURE IF EXISTS CreateIndexIfNotExistsWithColumns$$&#xD;&#xA;CREATE PROCEDURE `CreateIndexIfNotExistsWithColumns`(&#xD;&#xA;    IN tableName varchar(200), IN indexName VARCHAR(200),&#xD;&#xA;    IN columnName VARCHAR(200))&#xD;&#xA;BEGIN&#xD;&#xA;    DECLARE _tableCount INT;&#xD;&#xA;    DECLARE _indexCount INT;&#xD;&#xA;&#xD;&#xA;    SET&#xD;&#xA;        _tableCount = (&#xD;&#xA;            SELECT COUNT(1)&#xD;&#xA;            FROM INFORMATION_SCHEMA.TABLES&#xD;&#xA;            WHERE TABLE_SCHEMA = (&#xD;&#xA;                SELECT SCHEMA(&#xD;&#xA;                        )&#xD;&#xA;            )&#xD;&#xA;            AND TABLE_NAME = tableName);&#xD;&#xA;&#xD;&#xA;    SET&#xD;&#xA;        _indexCount = (&#xD;&#xA;            SELECT COUNT(1)&#xD;&#xA;            FROM information_schema.statistics&#xD;&#xA;            WHERE TABLE_SCHEMA = (&#xD;&#xA;                SELECT SCHEMA(&#xD;&#xA;                        )&#xD;&#xA;            )&#xD;&#xA;            AND TABLE_NAME = tableName&#xD;&#xA;            AND INDEX_NAME = CONCAT(&#39;IX_&#39;,&#xD;&#xA;                                    indexName)&#xD;&#xA;        );&#xD;&#xA;    IF _tableCount = 1&#xD;&#xA;        AND _indexCount = 0&#xD;&#xA;    THEN&#xD;&#xA;        SET&#xD;&#xA;            @_sqlText = CONCAT(&#39; CREATE INDEX `IX_&#39;,&#xD;&#xA;                            indexName, &#39;` ON `&#39;,&#xD;&#xA;                            tableName, &#39;`(&#39;,&#xD;&#xA;                            columnName, &#39;);&#xD;&#xA;&#39;);&#xD;&#xA;        PREPARE stmt1&#xD;&#xA;            FROM&#xD;&#xA;            @_sqlText;&#xD;&#xA;        EXECUTE stmt1;&#xD;&#xA;        DEALLOCATE PREPARE stmt1;&#xD;&#xA;    END IF;&#xD;&#xA;END$$&#xD;&#xA;&#xD;&#xA;# CreateUniqueIndexIfNotExistsWithColumns 添加组合唯一索引&#xD;&#xA;DROP&#xD;&#xA;    PROCEDURE IF EXISTS CreateUniqueIndexIfNotExistsWithColumns$$&#xD;&#xA;CREATE PROCEDURE `CreateUniqueIndexIfNotExistsWithColumns`(&#xD;&#xA;    IN tableName VARCHAR(200), IN indexName VARCHAR(200),&#xD;&#xA;    IN columnName VARCHAR(200))&#xD;&#xA;BEGIN&#xD;&#xA;    DECLARE _tableCount INT;&#xD;&#xA;    DECLARE _indexCount INT;&#xD;&#xA;&#xD;&#xA;    SET&#xD;&#xA;        _tableCount = (&#xD;&#xA;            SELECT COUNT(1)&#xD;&#xA;            FROM INFORMATION_SCHEMA.TABLES&#xD;&#xA;            WHERE TABLE_SCHEMA = (&#xD;&#xA;                SELECT SCHEMA(&#xD;&#xA;                        )&#xD;&#xA;            )&#xD;&#xA;            AND TABLE_NAME = tableName);&#xD;&#xA;&#xD;&#xA;    SET&#xD;&#xA;        _indexCount = (&#xD;&#xA;            SELECT COUNT(1)&#xD;&#xA;            FROM information_schema.statistics&#xD;&#xA;            WHERE TABLE_SCHEMA = (&#xD;&#xA;                SELECT SCHEMA(&#xD;&#xA;                        )&#xD;&#xA;            )&#xD;&#xA;            AND TABLE_NAME = tableName&#xD;&#xA;            AND INDEX_NAME = CONCAT(&#39;IX_&#39;,&#xD;&#xA;                                    indexName)&#xD;&#xA;        );&#xD;&#xA;    IF _tableCount = 1&#xD;&#xA;        AND _indexCount = 0&#xD;&#xA;    THEN&#xD;&#xA;        SET&#xD;&#xA;            @_sqlText = CONCAT(&#39; CREATE UNIQUE INDEX `IX_&#39;,&#xD;&#xA;                            indexName, &#39;` ON `&#39;,&#xD;&#xA;                            tableName, &#39;`(&#39;,&#xD;&#xA;                            columnName, &#39;);&#xD;&#xA;&#39;);&#xD;&#xA;        PREPARE stmt1&#xD;&#xA;            FROM&#xD;&#xA;            @_sqlText;&#xD;&#xA;        EXECUTE stmt1;&#xD;&#xA;        DEALLOCATE PREPARE stmt1;&#xD;&#xA;    END IF;&#xD;&#xA;END$$&#xD;&#xA;&#xD;&#xA;# DropIndexIfExists 删除索引&#xD;&#xA;DROP&#xD;&#xA;    PROCEDURE IF EXISTS DropIndexIfExists$$&#xD;&#xA;CREATE PROCEDURE `DropIndexIfExists`(&#xD;&#xA;    IN tableName varchar(100), IN indexName varchar(100))&#xD;&#xA;BEGIN&#xD;&#xA;    DECLARE _indexCount INT;&#xD;&#xA;&#xD;&#xA;    SET&#xD;&#xA;        _indexCount = (&#xD;&#xA;            SELECT COUNT(1)&#xD;&#xA;            FROM information_schema.statistics&#xD;&#xA;            WHERE TABLE_SCHEMA = (&#xD;&#xA;                SELECT SCHEMA(&#xD;&#xA;                        )&#xD;&#xA;            )&#xD;&#xA;            AND TABLE_NAME = tableName&#xD;&#xA;            AND INDEX_NAME = CONCAT(&#39;IX_&#39;,&#xD;&#xA;                                    indexName)&#xD;&#xA;        );&#xD;&#xA;    IF _indexCount &amp;gt; 0&#xD;&#xA;    THEN&#xD;&#xA;        SET&#xD;&#xA;            @_sqlText = CONCAT(&#39; DROP INDEX `IX_&#39;,&#xD;&#xA;                            indexName, &#39;` ON `&#39;,&#xD;&#xA;                            tableName, &#39;`; &#39;&#xD;&#xA;                );&#xD;&#xA;        PREPARE stmt1&#xD;&#xA;            FROM&#xD;&#xA;            @_sqlText;&#xD;&#xA;        EXECUTE stmt1; DEALLOCATE PREPARE stmt1;&#xD;&#xA;    END IF;&#xD;&#xA;END$$&#xD;&#xA;&#xD;&#xA;DELIMITER ;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Golang Defer理解</title>
      <link>/post/2022/01/13/25/</link>
      <pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate>
      <guid>/post/2022/01/13/25/</guid>
      <description>&lt;h3 id=&#34;结论&#34;&gt;结论&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;多个defer的执行顺序为&lt;code&gt;先进后出&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;匿名返回值是在&lt;code&gt;return&lt;/code&gt;执行时被声明，有名返回值则是在函数声明的同时被声明，因此在&lt;code&gt;defer&lt;/code&gt;语句中只能访问有名返回值，而不能直接访问匿名返回值&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;return&lt;/code&gt;其实应该包含前后两个步骤：第一步是给返回值赋值（若为有名返回值则直接赋值，若为匿名返回值则先声明再赋值）；第二步是调用&lt;code&gt;RET&lt;/code&gt;返回指令并传入返回值，而&lt;code&gt;RET&lt;/code&gt;则会检查&lt;code&gt;defer&lt;/code&gt;是否存在，若存在就先逆序插播defer语句，最后RET携带返回值退出函数&lt;/li&gt;&#xA;&lt;li&gt;延迟函数的参数在 defer 语句出现时就已经确定下来了（defer声明时会先计算确定参数的值，defer推迟执行的仅是其函数体）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;解释&#34;&gt;解释&lt;/h3&gt;&#xA;&lt;h5 id=&#34;结论1&#34;&gt;结论1&lt;/h5&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xD;&#xA;&#xD;&#xA;func main() {&#xD;&#xA;    for i := 0; i &amp;lt; 4; i++ {&#xD;&#xA;        defer fmt.Print(i)&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // Output:&#xD;&#xA;    // 3&#xD;&#xA;    // 2&#xD;&#xA;    // 1&#xD;&#xA;    // 0&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h5 id=&#34;结论2和结论3&#34;&gt;结论2和结论3&lt;/h5&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xD;&#xA;&#xD;&#xA;import (&#xD;&#xA;    &amp;quot;fmt&amp;quot;&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;func main() {&#xD;&#xA;    fmt.Println(a())&#xD;&#xA;&#xD;&#xA;    // Output:&#xD;&#xA;    // 1&#xD;&#xA;    // 2&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// 无名返回值&#xD;&#xA;func a() int {&#xD;&#xA;    defer func() { i++ }()&#xD;&#xA;    return 1&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// 有名返回值&#xD;&#xA;func a() (i int) {&#xD;&#xA;    defer func() { i++ }()&#xD;&#xA;    return 1&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h5 id=&#34;结论4&#34;&gt;结论4&lt;/h5&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xD;&#xA;&#xD;&#xA;import (&#xD;&#xA;    &amp;quot;fmt&amp;quot;&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;func main() {&#xD;&#xA;    a()&#xD;&#xA;    b()&#xD;&#xA;&#xD;&#xA;    // Output:&#xD;&#xA;    // 0&#xD;&#xA;    // enter: b&#xD;&#xA;    // in b&#xD;&#xA;    // leave: b&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func a() {&#xD;&#xA;    i := 0&#xD;&#xA;    defer fmt.Println(i) // 调用时i已经确定为0&#xD;&#xA;    i++&#xD;&#xA;    return&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func trace(s string) s {&#xD;&#xA;    fmt.Println(&amp;quot;enter: &amp;quot;, s)&#xD;&#xA;    return s&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func un(s) {&#xD;&#xA;    fmt.Println(&amp;quot;leave: &amp;quot;, s)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func b() {&#xD;&#xA;    defer un(trace(&amp;quot;b&amp;quot;)) // defer声明时会先计算确定参数的值，即执行了trace()，defer推迟执行的仅是其函数体un()&#xD;&#xA;    fmt.Println(&amp;quot;in b&amp;quot;)&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#53-defer&#34;&gt;《Go语言设计与实现》&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1410243&#34;&gt;Golang中defer、return、返回值之间执行顺序的坑&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/huang_yong_peng/article/details/82950743&#34;&gt;理解Golang中defer的使用&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Casbin 理解</title>
      <link>/post/2021/12/31/24/</link>
      <pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/12/31/24/</guid>
      <description>&lt;h3 id=&#34;rbac&#34;&gt;RBAC&lt;/h3&gt;&#xA;&lt;p&gt;model.conf&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;[request_definition]&#xD;&#xA;r = sub, obj, act&#xD;&#xA;&#xD;&#xA;[policy_definition]&#xD;&#xA;p = sub, obj, act&#xD;&#xA;&#xD;&#xA;[role_definition]&#xD;&#xA;g = _, _&#xD;&#xA;&#xD;&#xA;[policy_effect]&#xD;&#xA;e = some(where (p.eft == allow))&#xD;&#xA;&#xD;&#xA;[matchers]&#xD;&#xA;m = g(r.sub, p.sub) &amp;amp;&amp;amp; r.obj == p.obj &amp;amp;&amp;amp; r.act == p.act&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;casbin_rule&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;p, alice, data1, read&#xD;&#xA;p, bob, data2, write&#xD;&#xA;p, data2_admin, data2, read&#xD;&#xA;p, data2_admin, data2, write&#xD;&#xA;&#xD;&#xA;g, alice, data2_admin&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;粗略将&lt;code&gt;sub&lt;/code&gt;可以理解为角色、用户，将&lt;code&gt;obj&lt;/code&gt;理解为资源，将&lt;code&gt;act&lt;/code&gt;理解为操作&#xA;当&lt;code&gt;sub&lt;/code&gt;为用户时，即用户直接对资源进行授权&#xA;当&lt;code&gt;sub&lt;/code&gt;为角色时，即用户分配有某角色，某角色对资源进行授权&lt;/p&gt;&#xA;&lt;p&gt;从上面的例子可以看出&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;alice&lt;/code&gt;被授予了对&lt;code&gt;data1&lt;/code&gt;资源的读权限&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;bob&lt;/code&gt;被授予了对&lt;code&gt;data2&lt;/code&gt;资源的写权限&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;data2_admin&lt;/code&gt;被授予了&lt;code&gt;data2&lt;/code&gt;的读写权限，我们可以把&lt;code&gt;data2_admin&lt;/code&gt;可以理解为角色&lt;/li&gt;&#xA;&lt;li&gt;将&lt;code&gt;alice&lt;/code&gt;分配有&lt;code&gt;data2_admin&lt;/code&gt;角色，则&lt;code&gt;alice&lt;/code&gt;此时具有对&lt;code&gt;data2&lt;/code&gt;的读写权限&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;p：&lt;code&gt;用户、角色&lt;/code&gt;对&lt;code&gt;资源&lt;/code&gt;的授权&#xA;g：将&lt;code&gt;用户&lt;/code&gt;分配有&lt;code&gt;角色&lt;/code&gt;组&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 通过通道控制携程数量</title>
      <link>/post/2021/11/02/23/</link>
      <pubDate>Tue, 02 Nov 2021 17:31:00 +0000</pubDate>
      <guid>/post/2021/11/02/23/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {&#xD;&#xA;&#x9;var wg sync.WaitGroup&#xD;&#xA;&#x9;var ch = make(chan bool, 10)&#xD;&#xA;    for {&#xD;&#xA;        wg.Add(1)&#xD;&#xA;        ch &amp;lt;- true&#xD;&#xA;        go func() {&#xD;&#xA;            defer func() {&#xD;&#xA;                &amp;lt;- ch&#xD;&#xA;                wg.Done()&#xD;&#xA;            }()&#xD;&#xA;            // 逻辑&#xD;&#xA;            ...&#xD;&#xA;        }()&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    wg.Wait()&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Homebrew 安装软件加速</title>
      <link>/post/2021/10/23/22/</link>
      <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/10/23/22/</guid>
      <description>&lt;h2 id=&#34;加速&#34;&gt;加速&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;安装代理软件 &lt;a href=&#34;https://github.com/yichengchen/clashX&#34;&gt;https://github.com/yichengchen/clashX&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;两种方法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;方法一（好处：可控，需要进行brew更新才使用；坏处：较为繁琐）&lt;/p&gt;&#xA;&lt;p&gt;在&lt;code&gt;.bashrc&lt;/code&gt;或&lt;code&gt;.zshrc&lt;/code&gt;设置&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ALIAS&#xD;&#xA;alias proxy=&amp;quot;export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890; echo &#39;Proxy on&#39;&amp;quot;&#xD;&#xA;alias unproxy=&amp;quot;unset https_proxy http_proxy all_proxy; echo &#39;Proxy off&#39;&amp;quot;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;生效&lt;code&gt;source .zshrc&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;每次iTerm2设置登录执行&lt;code&gt;proxy&lt;/code&gt;或手动执行&lt;code&gt;proxy&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;方法二（好处：便捷；坏处：可能影响其他命令）&lt;/p&gt;&#xA;&lt;p&gt;在&lt;code&gt;.bashrc&lt;/code&gt;或&lt;code&gt;.zshrc&lt;/code&gt;设置&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Proxy&#xD;&#xA;export https_proxy=http://127.0.0.1:7890&#xD;&#xA;export http_proxy=http://127.0.0.1:7890&#xD;&#xA;export all_proxy=socks5://127.0.0.1:7890&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;生效&lt;code&gt;source .zshrc&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;执行命令&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/bin/bash -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&amp;quot;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;按照指令安装&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;执行命令查看是否正常&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew -v&#xD;&#xA;&#xA;# output:&#xD;&#xA;# Homebrew 3.2.17-133-g890190c&#xD;&#xA;# Homebrew/homebrew-core (git revision 5d84b1431d6; last commit 2021-10-23)&#xD;&#xA;# Homebrew/homebrew-cask (git revision 65500e81bf; last commit 2021-10-23)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;更新 Homebrew 自己&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew update&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查看哪些安装包需要更新：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew outdated&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;列出已安装包&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew list&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;更新&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew upgrade             # 更新所有的包&#xD;&#xA;brew upgrade $FORMULA    # 更新指定的包&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;清理旧版本&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew cleanup             # 清理所有包的旧版本&#xD;&#xA;brew cleanup $FORMULA    # 清理指定包的旧版本&#xD;&#xA;brew cleanup -n          # 查看可清理的旧版本包，不执行实际操作&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;锁定不想更新的包&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew pin $FORMULA      # 锁定某个包&#xD;&#xA;brew unpin $FORMULA    # 取消锁定&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查看安装包的相关信息&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew info $FORMULA    # 显示某个包的信息&#xD;&#xA;brew info             # 显示安装了包数量，文件数量，和总占用空间&#xD;&#xA;brew deps --installed --tree # 查看已安装的包的依赖，树形显示&#xD;&#xA;# `brew info` 可以查看包的相关信息，最有用的应该是包依赖和相应的命令。比如 Nginx 会提醒你怎么加 launchctl，PostgreSQL 会告诉你如何迁移数据库。这些信息会在包安装完成后自动显示，如果忘了的话可以用这个命令很方便地查看。&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew rm $FORMULA                # 删除某个包&#xD;&#xA;brew uninstall --force $FORMULA # 删除所有版本&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Git相关配置</title>
      <link>/post/2021/10/20/20/</link>
      <pubDate>Wed, 20 Oct 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/10/20/20/</guid>
      <description>&lt;h4 id=&#34;用户名邮箱设置&#34;&gt;用户名邮箱设置&lt;/h4&gt;&#xA;&lt;p&gt;系统级别&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global user.name &amp;quot;xxx&amp;quot;&#xD;&#xA;git config --global user.email &amp;quot;xxx@xxx.com&amp;quot;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;仓库级别&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --local user.name &amp;quot;xxx&amp;quot;&#xD;&#xA;git config --local user.email &amp;quot;xxx@xxx.com&amp;quot;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;代理设置&#34;&gt;代理设置&lt;/h4&gt;&#xA;&lt;p&gt;添加代理&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --local http.proxy &amp;quot;http://127.0.0.1:7890&amp;quot;&#xD;&#xA;git config --local https.proxy &amp;quot;http://127.0.0.1:7890&amp;quot;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;删除代理&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --local --unset http.proxy&#xD;&#xA;git config --local --unset https.proxy&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Linux 安装 Git</title>
      <link>/post/2021/06/10/16/</link>
      <pubDate>Thu, 10 Jun 2021 17:40:00 +0000</pubDate>
      <guid>/post/2021/06/10/16/</guid>
      <description>&lt;h3 id=&#34;场景&#34;&gt;场景&lt;/h3&gt;&#xA;&lt;p&gt;一般来说linux安装通过&lt;code&gt;yum&lt;/code&gt;或者&lt;code&gt;apt-get&lt;/code&gt;命令安装即可，但是使用此类命令，git安装版本太低了，因此需要编译安装&lt;/p&gt;&#xA;&lt;h3 id=&#34;源码安装git&#34;&gt;源码安装Git&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查看&lt;code&gt;https://github.com/git/git/releases&lt;/code&gt;版本&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;选择需要下载的版本地址，比如&lt;code&gt;2.32.1&lt;/code&gt;，复制链接地址&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://imgtu.com/i/2RSIHg&#34;&gt;&lt;img src=&#34;https://z3.ax1x.com/2021/06/10/2RSIHg.png&#34; alt=&#34;复制链接地址&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;下载并解压，安装所需依赖，编译&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 下载&#xD;&#xA;wget https://github.com/git/git/archive/refs/tags/v2.32.0.tar.gz&#xD;&#xA;# 解压&#xD;&#xA;tar -zxvf v2.32.0.tar.gz&#xD;&#xA;# 安装所需依赖（如果编译出现确实依赖，按此方法安装即可）&#xD;&#xA;yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker&#xD;&#xA;# 编译&#xD;&#xA;cd v2.32.0.tar.gz &amp;amp;&amp;amp; make prefix=/usr/local/git all&#xD;&#xA;# 安装&#xD;&#xA;make prefix=/usr/local/git install&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;设置环境变量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim etc/profile&#xD;&#xA;# 添加环境&#xD;&#xA;export PATH=$PATH:/usr/local/git/bin&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;安装完成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看安装的git版本，校验通过，安装成功&#xD;&#xA;git version&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Window Terminal配置</title>
      <link>/post/2021/06/10/18/</link>
      <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/06/10/18/</guid>
      <description>&lt;h3 id=&#34;场景&#34;&gt;场景&lt;/h3&gt;&#xA;&lt;p&gt;最近发现一个 Shell 利器，Windows Terminal，可以在微软商店自行下载&lt;/p&gt;&#xA;&lt;h3 id=&#34;git-bash&#34;&gt;Git-Bash&lt;/h3&gt;&#xA;&lt;p&gt;前置要求是安装好 Git，比如作者的 Git 目录为&lt;code&gt;D:\Git&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;配置&#34;&gt;配置&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;点击设置&#xA;&lt;a href=&#34;https://imgtu.com/i/2RFyE8&#34;&gt;&lt;img src=&#34;https://z3.ax1x.com/2021/06/10/2RFyE8.png&#34; alt=&#34;2RFyE8.png&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;点击左下角，新增，会出现一个默认配置，可以选择 json 编辑，也可以图形化配置&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;名称自由编辑&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;命令行，填写 Git 安装目录下 bin 目录的 bin.exe，比如&lt;code&gt;D:\Git\bin\bash.exe&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;启动目录，&lt;code&gt;%USERPROFILE%&lt;/code&gt;即可&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;总体算完成了&lt;/p&gt;&#xA;&lt;h4 id=&#34;补充&#34;&gt;补充&lt;/h4&gt;&#xA;&lt;p&gt;细心的读者会发现部分命令比如&lt;code&gt;ll&lt;/code&gt;在 git-bash 可以使用，但是在 Terminal 下的 bash 不能使用&#xA;需要我们自行添加&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# 编辑Git安装目录D:\Git\vendor\etc下的bash.bashrc文件&#xD;&#xA;# 新增&#xD;&#xA;alias ll=&amp;quot;ls -l&amp;quot;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;保存即可&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux 安装 Golang</title>
      <link>/post/2021/06/09/17/</link>
      <pubDate>Wed, 09 Jun 2021 17:41:00 +0000</pubDate>
      <guid>/post/2021/06/09/17/</guid>
      <description>&lt;h3 id=&#34;场景&#34;&gt;场景&lt;/h3&gt;&#xA;&lt;p&gt;使用&lt;code&gt;yum&lt;/code&gt;或&lt;code&gt;apt-get&lt;/code&gt;命令安装，版本不好控制，使用源码安装&lt;/p&gt;&#xA;&lt;h3 id=&#34;源码安装&#34;&gt;源码安装&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查看&lt;code&gt;https://studygolang.com/dl&lt;/code&gt;所需安装版本的地址&#xA;&lt;a href=&#34;https://imgtu.com/i/2RP9Ug&#34;&gt;&lt;img src=&#34;https://z3.ax1x.com/2021/06/10/2RP9Ug.png&#34; alt=&#34;2RP9Ug.png&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;下载&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wget https://studygolang.com/dl/golang/go1.15.13.linux-amd64.tar.gz&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解压&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar -zxvf go1.15.13.linux-amd64.tar.gz&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;移动&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mv go /usr/local/go&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;添加环境变量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 打开&#xD;&#xA;vim /etc/profile&#xD;&#xA;# 添加&#xD;&#xA;export GOROOT=/usr/local/go&#xD;&#xA;export PATH=$PATH:$GOROOT/bin&#xD;&#xA;# 运行&#xD;&#xA;source /etc/profile&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;安装完成&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看安装的go版本，校验通过，安装成功&#xD;&#xA;go version&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Golang AES-128/GCM &#43; BASE64 加密</title>
      <link>/post/2021/03/15/14/</link>
      <pubDate>Mon, 15 Mar 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/03/15/14/</guid>
      <description>&lt;p&gt;需求背景：接入网络游戏防沉迷系统，其中请求体body需要进行加密，和签名&lt;/p&gt;&#xA;&lt;h4 id=&#34;加密&#34;&gt;加密&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func GCMEncrypt(secretKey, originalText string) (string, error) {&#xD;&#xA;&#x9;// 密钥需要解码&#xD;&#xA;&#x9;key, _ := hex.DecodeString(secretKey)&#xD;&#xA;&#x9;block, err := aes.NewCipher(key)&#xD;&#xA;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, err&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;aesGcm, err := cipher.NewGCM(block)&#xD;&#xA;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, err&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;// 向量&#xD;&#xA;&#x9;nonce := make([]byte, aesGcm.NonceSize())&#xD;&#xA;&#x9;if _, err := io.ReadFull(rand.Reader, nonce); err != nil {&#xD;&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, err&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;cipherText := aesGcm.Seal(nonce, nonce, []byte(originalText), nil)&#xD;&#xA;&#xD;&#xA;&#x9;// encode as base64 string&#xD;&#xA;&#x9;encoded := base64.StdEncoding.EncodeToString(cipherText)&#xD;&#xA;&#x9;return encoded, nil&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;签名&#34;&gt;签名&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (s *encryptService) Sign(headers, body map[string]string) string {&#xD;&#xA;&#x9;var data string&#xD;&#xA;&#x9;var keys []string&#xD;&#xA;&#x9;// key排序&#xD;&#xA;&#x9;for k := range headers {&#xD;&#xA;&#x9;&#x9;keys = append(keys, k)&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;sort.Strings(keys)&#xD;&#xA;&#xD;&#xA;&#x9;// 拼接&#xD;&#xA;&#x9;for _, k := range keys {&#xD;&#xA;&#x9;&#x9;data = data + k + headers[k]&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;data = s.appSecret + data + gconv.String(body)&#xD;&#xA;&#xD;&#xA;&#x9;// 对字符串进行sha256哈希&#xD;&#xA;&#x9;h := sha256.New()&#xD;&#xA;&#x9;h.Write([]byte(data))&#xD;&#xA;&#x9;sum := h.Sum(nil)&#xD;&#xA;&#x9;return hex.EncodeToString(sum)&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 参数初始化&#xD;&#xA;headers := map[string]string{&#xD;&#xA;&#x9;&amp;quot;appId&amp;quot;:      &amp;quot;xxxxxxxx&amp;quot;,&#xD;&#xA;&#x9;&amp;quot;bizId&amp;quot;:      &amp;quot;xxxxxxxx&amp;quot;,&#xD;&#xA;&#x9;&amp;quot;timestamps&amp;quot;: strconv.Itoa(int(time.Now().UnixNano() / 1e6)),&#xD;&#xA;}&#xD;&#xA;// 请求体加密&#xD;&#xA;jsonByte, _ := json.Marshal(req)&#xD;&#xA;cipher, _ := GCMEncrypt(string(jsonByte), &#39;xxxxxxxxx&#39;) // 第二个参数是密钥&#xD;&#xA;body := map[string]string{&#xD;&#xA;&#x9;&amp;quot;data&amp;quot;: cipher,&#xD;&#xA;}&#xD;&#xA;// 生成签名&#xD;&#xA;headers[&amp;quot;sign&amp;quot;] = Encrypt.Sign(headers, body)&#xD;&#xA;headers[&amp;quot;Content-Type&amp;quot;] = &amp;quot;application/json&amp;quot;&#xD;&#xA;.....发http请求&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Laravel 契约和门面简单解读</title>
      <link>/post/2020/03/30/11/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate>
      <guid>/post/2020/03/30/11/</guid>
      <description>&lt;p&gt;最近笔者正在理解Larvael服务容器、服务提供者、门面、契约的关系。&#xA;今天主要是记录自己借Laravel自带的Cache模块进行一个讲解。&lt;/p&gt;&#xA;&lt;h3 id=&#34;代码和流程&#34;&gt;代码和流程&lt;/h3&gt;&#xA;&lt;p&gt;首先我们打开&lt;code&gt;config\app.php&lt;/code&gt;中&lt;code&gt;providers&lt;/code&gt;下有一个服务提供者&lt;code&gt;Illuminate\Cache\CacheServiceProvider::class&lt;/code&gt;&lt;br&gt;&#xA;我们看看他的服务提供者是怎么写的：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public function register()&#xD;&#xA;    {&#xD;&#xA;        $this-&amp;gt;app-&amp;gt;singleton(&#39;cache&#39;, function ($app) {&#xD;&#xA;            return new CacheManager($app);&#xD;&#xA;        });&#xD;&#xA;&#xD;&#xA;        $this-&amp;gt;app-&amp;gt;singleton(&#39;cache.store&#39;, function ($app) {&#xD;&#xA;            return $app[&#39;cache&#39;]-&amp;gt;driver();&#xD;&#xA;        });&#xD;&#xA;&#xD;&#xA;        $this-&amp;gt;app-&amp;gt;singleton(&#39;cache.psr6&#39;, function ($app) {&#xD;&#xA;            return new Psr16Adapter($app[&#39;cache.store&#39;]);&#xD;&#xA;        });&#xD;&#xA;&#xD;&#xA;        $this-&amp;gt;app-&amp;gt;singleton(&#39;memcached.connector&#39;, function () {&#xD;&#xA;            return new MemcachedConnector;&#xD;&#xA;        });&#xD;&#xA;    }&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;我们主要看&lt;code&gt;cache&lt;/code&gt;这个门面，它所单例绑定的是&lt;code&gt;CacheManager&lt;/code&gt;，我们继续深入&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?php&#xD;&#xA;&#xD;&#xA;namespace Illuminate\Cache;&#xD;&#xA;&#xD;&#xA;use Aws\DynamoDb\DynamoDbClient;&#xD;&#xA;use Closure;&#xD;&#xA;use Illuminate\Contracts\Cache\Factory as FactoryContract;&#xD;&#xA;use Illuminate\Contracts\Cache\Store;&#xD;&#xA;use Illuminate\Contracts\Events\Dispatcher as DispatcherContract;&#xD;&#xA;use Illuminate\Support\Arr;&#xD;&#xA;use InvalidArgumentException;&#xD;&#xA;&#xD;&#xA;/**&#xD;&#xA; * @mixin \Illuminate\Contracts\Cache\Repository&#xD;&#xA; */&#xD;&#xA;class CacheManager implements FactoryContract&#xD;&#xA;{&#xD;&#xA;    /**&#xD;&#xA;     * The application instance.&#xD;&#xA;     *&#xD;&#xA;     * @var \Illuminate\Contracts\Foundation\Application&#xD;&#xA;     */&#xD;&#xA;    protected $app;&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * The array of resolved cache stores.&#xD;&#xA;     *&#xD;&#xA;     * @var array&#xD;&#xA;     */&#xD;&#xA;    protected $stores = [];&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * The registered custom driver creators.&#xD;&#xA;     *&#xD;&#xA;     * @var array&#xD;&#xA;     */&#xD;&#xA;    protected $customCreators = [];&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Create a new Cache manager instance.&#xD;&#xA;     *&#xD;&#xA;     * @param  \Illuminate\Contracts\Foundation\Application  $app&#xD;&#xA;     * @return void&#xD;&#xA;     */&#xD;&#xA;    public function __construct($app)&#xD;&#xA;    {&#xD;&#xA;        $this-&amp;gt;app = $app;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Get a cache store instance by name, wrapped in a repository.&#xD;&#xA;     *&#xD;&#xA;     * @param  string|null  $name&#xD;&#xA;     * @return \Illuminate\Contracts\Cache\Repository&#xD;&#xA;     */&#xD;&#xA;    public function store($name = null)&#xD;&#xA;    {&#xD;&#xA;        $name = $name ?: $this-&amp;gt;getDefaultDriver();&#xD;&#xA;&#xD;&#xA;        return $this-&amp;gt;stores[$name] = $this-&amp;gt;get($name);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Get a cache driver instance.&#xD;&#xA;     *&#xD;&#xA;     * @param  string|null  $driver&#xD;&#xA;     * @return \Illuminate\Contracts\Cache\Repository&#xD;&#xA;     */&#xD;&#xA;    public function driver($driver = null)&#xD;&#xA;    {&#xD;&#xA;        return $this-&amp;gt;store($driver);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Attempt to get the store from the local cache.&#xD;&#xA;     *&#xD;&#xA;     * @param  string  $name&#xD;&#xA;     * @return \Illuminate\Contracts\Cache\Repository&#xD;&#xA;     */&#xD;&#xA;    protected function get($name)&#xD;&#xA;    {&#xD;&#xA;        return $this-&amp;gt;stores[$name] ?? $this-&amp;gt;resolve($name);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Resolve the given store.&#xD;&#xA;     *&#xD;&#xA;     * @param  string  $name&#xD;&#xA;     * @return \Illuminate\Contracts\Cache\Repository&#xD;&#xA;     *&#xD;&#xA;     * @throws \InvalidArgumentException&#xD;&#xA;     */&#xD;&#xA;    protected function resolve($name)&#xD;&#xA;    {&#xD;&#xA;        $config = $this-&amp;gt;getConfig($name);&#xD;&#xA;&#xD;&#xA;        if (is_null($config)) {&#xD;&#xA;            throw new InvalidArgumentException(&amp;quot;Cache store [{$name}] is not defined.&amp;quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        if (isset($this-&amp;gt;customCreators[$config[&#39;driver&#39;]])) {&#xD;&#xA;            return $this-&amp;gt;callCustomCreator($config);&#xD;&#xA;        } else {&#xD;&#xA;            $driverMethod = &#39;create&#39;.ucfirst($config[&#39;driver&#39;]).&#39;Driver&#39;;&#xD;&#xA;&#xD;&#xA;            if (method_exists($this, $driverMethod)) {&#xD;&#xA;                return $this-&amp;gt;{$driverMethod}($config);&#xD;&#xA;            } else {&#xD;&#xA;                throw new InvalidArgumentException(&amp;quot;Driver [{$config[&#39;driver&#39;]}] is not supported.&amp;quot;);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Call a custom driver creator.&#xD;&#xA;     *&#xD;&#xA;     * @param  array  $config&#xD;&#xA;     * @return mixed&#xD;&#xA;     */&#xD;&#xA;    protected function callCustomCreator(array $config)&#xD;&#xA;    {&#xD;&#xA;        return $this-&amp;gt;customCreators[$config[&#39;driver&#39;]]($this-&amp;gt;app, $config);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    ......&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Create an instance of the file cache driver.&#xD;&#xA;     *&#xD;&#xA;     * @param  array  $config&#xD;&#xA;     * @return \Illuminate\Cache\Repository&#xD;&#xA;     */&#xD;&#xA;    protected function createFileDriver(array $config)&#xD;&#xA;    {&#xD;&#xA;        return $this-&amp;gt;repository(new FileStore($this-&amp;gt;app[&#39;files&#39;], $config[&#39;path&#39;]));&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Create a new cache repository with the given implementation.&#xD;&#xA;     *&#xD;&#xA;     * @param  \Illuminate\Contracts\Cache\Store  $store&#xD;&#xA;     * @return \Illuminate\Cache\Repository&#xD;&#xA;     */&#xD;&#xA;    public function repository(Store $store)&#xD;&#xA;    {&#xD;&#xA;        return tap(new Repository($store), function ($repository) {&#xD;&#xA;            $this-&amp;gt;setEventDispatcher($repository);&#xD;&#xA;        });&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Set the event dispatcher on the given repository instance.&#xD;&#xA;     *&#xD;&#xA;     * @param  \Illuminate\Cache\Repository  $repository&#xD;&#xA;     * @return void&#xD;&#xA;     */&#xD;&#xA;    protected function setEventDispatcher(Repository $repository)&#xD;&#xA;    {&#xD;&#xA;        if (! $this-&amp;gt;app-&amp;gt;bound(DispatcherContract::class)) {&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        $repository-&amp;gt;setEventDispatcher(&#xD;&#xA;            $this-&amp;gt;app[DispatcherContract::class]&#xD;&#xA;        );&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    ......&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Get the cache connection configuration.&#xD;&#xA;     *&#xD;&#xA;     * @param  string  $name&#xD;&#xA;     * @return array&#xD;&#xA;     */&#xD;&#xA;    protected function getConfig($name)&#xD;&#xA;    {&#xD;&#xA;        return $this-&amp;gt;app[&#39;config&#39;][&amp;quot;cache.stores.{$name}&amp;quot;];&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    ......&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Dynamically call the default driver instance.&#xD;&#xA;     *&#xD;&#xA;     * @param  string  $method&#xD;&#xA;     * @param  array  $parameters&#xD;&#xA;     * @return mixed&#xD;&#xA;     */&#xD;&#xA;    public function __call($method, $parameters)&#xD;&#xA;    {&#xD;&#xA;        return $this-&amp;gt;store()-&amp;gt;$method(...$parameters);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;我们以Laravel默认的File存储讲起：&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于</title>
      <link>/about/</link>
      <pubDate>Fri, 18 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/about/</guid>
      <description>&lt;h3 id=&#34;yoo-im-mingzaily-&#34;&gt;Yoo, I&amp;rsquo;m mingzaily 👋&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/mingzaily&#34;&gt;&lt;img src=&#34;https://img.shields.io/badge/dynamic/json?logo=github&amp;amp;label=GitHub&amp;amp;labelColor=495867&amp;amp;color=495867&amp;amp;query=%24.data.totalSubs&amp;amp;url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dgithub%26queryKey%3Dmingzaily&amp;amp;style=flat-square&#34; alt=&#34;GitHub&#34;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;⚡ Golang / PHP.&lt;/li&gt;&#xA;&lt;li&gt;✍️ &lt;a href=&#34;https://www.mingzaily.com&#34;&gt;Blogger&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;🏃 羽毛球&lt;/li&gt;&#xA;&lt;li&gt;🥋 电脑游戏，NAS&lt;/li&gt;&#xA;&lt;li&gt;♟ 中国象棋&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github-readme-stats.vercel.app/api?username=mingzaily&#34; alt=&#34;&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据库</title>
      <link>/post/2019/10/18/8/</link>
      <pubDate>Fri, 18 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/post/2019/10/18/8/</guid>
      <description>&lt;h2 id=&#34;数据库架构&#34;&gt;数据库架构&lt;/h2&gt;&#xA;&lt;h3 id=&#34;数据库设计&#34;&gt;数据库设计&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;程序实例&#xA;&lt;ul&gt;&#xA;&lt;li&gt;存储管理&lt;/li&gt;&#xA;&lt;li&gt;缓存机制&lt;/li&gt;&#xA;&lt;li&gt;SQL 解析&lt;/li&gt;&#xA;&lt;li&gt;日志管理&lt;/li&gt;&#xA;&lt;li&gt;权限划分&lt;/li&gt;&#xA;&lt;li&gt;容灾机制&lt;/li&gt;&#xA;&lt;li&gt;索引管理&lt;/li&gt;&#xA;&lt;li&gt;锁管理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;存储（文件系统）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;索引模块&#34;&gt;索引模块&lt;/h3&gt;&#xA;&lt;p&gt;官方方对索引的定义为：索引是帮助 MySQL 高效获取数据的数据结构&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;为什么要用索引&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;快速查询数据&lt;/li&gt;&#xA;&lt;li&gt;保证数据的唯一性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;索引的优缺点&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;优点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;大大加快数据检索速度&lt;/li&gt;&#xA;&lt;li&gt;创建唯一索引，保证数据库表中每行数据的唯一性&lt;/li&gt;&#xA;&lt;li&gt;加速表之间的连接&lt;/li&gt;&#xA;&lt;li&gt;减少查询中分组和排序的时间&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;缺点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;需要占用物理空间&lt;/li&gt;&#xA;&lt;li&gt;对表中数据进行增加、删除和修改时索引也要更新，降低了数据维护速度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;什么样的信息能成为索引&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主键、唯一键以及普通键等等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;索引的数据结构&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;生成索引，建立二叉查找树进行二分查找 效率 O(logn)&lt;/li&gt;&#xA;&lt;li&gt;生成索引，建立 B-Tree 进行查找 效率 O(logn)&#xA;&lt;ul&gt;&#xA;&lt;li&gt;B-Tree&lt;/li&gt;&#xA;&lt;li&gt;根节点至少包括两个孩子&lt;/li&gt;&#xA;&lt;li&gt;树中每个节点最多含有 m 个孩子(m&amp;gt;=2)&lt;/li&gt;&#xA;&lt;li&gt;除根节点和叶子节点外，其他每个节点至少有 ceil(m/2)个孩子&lt;/li&gt;&#xA;&lt;li&gt;所有叶子节点都位于同一层&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;生成索引，建立 B+-Tree 进行查找（主流）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;定义基本与 B-Tree 一致&lt;/li&gt;&#xA;&lt;li&gt;非叶子节点的子树指针与关键字个数相同&lt;/li&gt;&#xA;&lt;li&gt;非叶子节点仅使用索引，数据都保存在叶子节点中&lt;/li&gt;&#xA;&lt;li&gt;所有叶子节点均有一个链指针指向下一个叶子节点&lt;/li&gt;&#xA;&lt;li&gt;B+-Tree 更适合用来做存储引擎&#xA;&lt;ul&gt;&#xA;&lt;li&gt;B+树的磁盘读写代价更低&lt;/li&gt;&#xA;&lt;li&gt;B+树的查询效率更加稳定&lt;/li&gt;&#xA;&lt;li&gt;B+树更有利于对数据库的扫描&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;生成索引，建立 Hash 结构进行查找&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询效率更高&lt;/li&gt;&#xA;&lt;li&gt;缺点&#xA;&lt;ul&gt;&#xA;&lt;li&gt;仅仅能满足&amp;quot;=&amp;quot;，&amp;ldquo;IN&amp;rdquo;，不能使用范围查询&lt;/li&gt;&#xA;&lt;li&gt;无法被用来避免数据的排序操作&lt;/li&gt;&#xA;&lt;li&gt;不能利用部分索引键查询&lt;/li&gt;&#xA;&lt;li&gt;不能避免表扫码&lt;/li&gt;&#xA;&lt;li&gt;遇到大量 Hash 值相等的情况后性能并不一定就会比 B-Tree 索引高&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;BitMap 索引&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;密集索引和稀疏索引的区别&lt;/p&gt;</description>
    </item>
    <item>
      <title>计算机网络</title>
      <link>/post/2019/10/18/7/</link>
      <pubDate>Fri, 18 Oct 2019 00:00:00 +0000</pubDate>
      <guid>/post/2019/10/18/7/</guid>
      <description>&lt;h2 id=&#34;网络基础&#34;&gt;网络基础&lt;/h2&gt;&#xA;&lt;h3 id=&#34;osi-模型&#34;&gt;OSI 模型&lt;/h3&gt;&#xA;&lt;h4 id=&#34;表格&#34;&gt;表格&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;概念层&lt;/th&gt;&#xA;          &lt;th&gt;数据单位&lt;/th&gt;&#xA;          &lt;th&gt;作用&lt;/th&gt;&#xA;          &lt;th&gt;设备&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;物理层&lt;/td&gt;&#xA;          &lt;td&gt;比特&lt;/td&gt;&#xA;          &lt;td&gt;提供光纤标准、传送数据的通路，传输比特流&lt;/td&gt;&#xA;          &lt;td&gt;网线等等&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;数据链路层&lt;/td&gt;&#xA;          &lt;td&gt;数据帧&lt;/td&gt;&#xA;          &lt;td&gt;帧定界和帧同步;顺序控制，指对帧的收发顺序的控制；差错检测和恢复；APR、RARP 协议&lt;/td&gt;&#xA;          &lt;td&gt;交互机、网桥&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;网络层&lt;/td&gt;&#xA;          &lt;td&gt;数据分组或数据包&lt;/td&gt;&#xA;          &lt;td&gt;两个主机系统之间提供连接和路径选择&lt;/td&gt;&#xA;          &lt;td&gt;路由器&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;传输层&lt;/td&gt;&#xA;          &lt;td&gt;报文段&lt;/td&gt;&#xA;          &lt;td&gt;定义传输协议和端口；分段传输，到达目的地址后重组&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;会话层&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;管理应用程序间的通信&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;表示层&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;把应用层提供的信息变换为能够共同理解的形式、保证各系统、应用可以读取&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;应用层&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;          &lt;td&gt;应用层协议，如 HTTP 协议&lt;/td&gt;&#xA;          &lt;td&gt;-&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;下面 4 层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；&lt;/li&gt;&#xA;&lt;li&gt;第 4 层(传输成 TCP/UDP)作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；&lt;/li&gt;&#xA;&lt;li&gt;简言之，下 4 层主要完成通信子网的功能，上 3 层主要完成资源子网的功能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;tcpip-四层模型&#34;&gt;TCP/IP 四层模型&lt;/h3&gt;&#xA;&lt;p&gt;TCP/IP 又叫网际协议群，可以说是 OSI 模型的实现，强调在计算机上实现协议应该开发哪种程序&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;概念层&lt;/th&gt;&#xA;          &lt;th&gt;TCP/IP 协议群&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;应用层&lt;/td&gt;&#xA;          &lt;td&gt;FTP、HTTP、Telnt&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;数据链路层&lt;/td&gt;&#xA;          &lt;td&gt;TCP、UDP&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;网络层&lt;/td&gt;&#xA;          &lt;td&gt;IP、ICMP、RIP、OSFF，ICMP，BGF&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;网络接口层/链路层&lt;/td&gt;&#xA;          &lt;td&gt;ISO、IEEE 标准&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;tcp-三次握手四次挥手&#34;&gt;TCP 三次握手&amp;amp;四次挥手&lt;/h2&gt;&#xA;&lt;h3 id=&#34;报文格式&#34;&gt;报文格式&lt;/h3&gt;&#xA;&lt;p&gt;TCP Tags&lt;/p&gt;</description>
    </item>
    <item>
      <title>说说</title>
      <link>/shuoshuo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>/shuoshuo/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;又快过年了，2023 年就过去了，感觉啥也没干呢，😌&lt;/p&gt;&#xA;&lt;/blockquote&gt;</description>
    </item>
  </channel>
</rss>
