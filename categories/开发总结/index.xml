<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>开发总结 on 星河</title><link>/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</link><description>Recent content in 开发总结 on 星河</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Tue, 21 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang 简易WS服务 - 客户端</title><link>/post/2023/02/21/42/</link><pubDate>Tue, 21 Feb 2023 00:00:00 +0000</pubDate><guid>/post/2023/02/21/42/</guid><description>&lt;p>客户端代码较为简单&lt;/p>
&lt;pre>&lt;code class="language-golang">
type SocketClient struct {
	host string
	isClosed chan bool
	log *logger.Log // 自定义的log包
}

type wsMessage struct {
	Type int `json:&amp;quot;type&amp;quot;`
	Data interface{} `json:&amp;quot;data&amp;quot;`
}

func NewSocketClient(configPath, logPath, host string) *SocketClient {
	w := io.MultiWriter(os.Stdout)
	if logPath != &amp;quot;&amp;quot; {
		f, err := util.OpenFile(logPath)
		if err != nil {
			panic(err)
		}
		w = io.MultiWriter(os.Stdout, f)
	}

	return &amp;amp;SocketClient{
		host: host,
		isClosed: make(chan bool),
		log: logger.New(w, logger.LINFO, log.LstdFlags|log.Lmsgprefix),
	}
}

func (s *SocketClient) Start() {
	// 设置在线
	ClientStatus = ClientStatusOnline

	// 连接服务器
	u := url.URL{Scheme: &amp;quot;ws&amp;quot;, Host: s.host, Path: &amp;quot;/socket&amp;quot;}
	s.log.Info(&amp;quot;正在连接到&amp;quot;, u.String())

	conn, _, err := websocket.DefaultDialer.Dial(u.String(), nil)
	if err != nil {
		s.log.ErrorF(&amp;quot;连接到服务器错误: %v&amp;quot;, err)
	}
	defer conn.Close()

	s.log.Info(&amp;quot;已连接到服务器&amp;quot;)

	interrupt := make(chan os.Signal, 1)

	// 监听中断信号
	signal.Notify(interrupt, syscall.SIGKILL, syscall.SIGINT, syscall.SIGTERM, os.Kill)
	// 心跳包
	go s.pingHandler(conn)
	// 接收消息
	go s.receiveHandler(conn)

	for {
		select {
		case &amp;lt;-interrupt:
			s.log.Info(&amp;quot;收到SIGINT中断信号，正在关闭ws连接。。。&amp;quot;)
			_ = conn.WriteControl(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, &amp;quot;&amp;quot;), time.Now().Add(time.Second))
			select {
			case &amp;lt;-s.isClosed:
				s.log.Info(&amp;quot;WS链接已关闭，退出中。。。&amp;quot;)
			case &amp;lt;-time.After(time.Duration(1) * time.Second):
				s.log.Info(&amp;quot;关闭ws链接超时，退出中。。。&amp;quot;)
			}
			return
		case &amp;lt;-s.isClosed:
			s.log.Info(&amp;quot;ws链接已关闭，退出中。。。&amp;quot;)
			return
		}
	}
}

func (s *SocketClient) pingHandler(conn *websocket.Conn) {
	ticker := time.NewTicker(pingTime)
	for {
		select {
		case &amp;lt;-ticker.C:
			status := strconv.FormatInt(int64(ClientStatus), 10)
			err := conn.WriteMessage(websocket.PingMessage, []byte(status))
			if err != nil {
				s.log.ErrorF(&amp;quot;发送心跳包错误: %v&amp;quot;, err)
				return
			}
		case &amp;lt;-s.isClosed:
			return
		}
	}
}

func (s *SocketClient) receiveHandler(ws *websocket.Conn) {
	defer close(s.isClosed)
	for {
		messageType, message, err := ws.ReadMessage()
		if err != nil {
			s.log.ErrorF(&amp;quot;读取消息 %v&amp;quot;, err)
			return
		}
		switch messageType {
		case websocket.TextMessage:
			var textMessage *wsMessage

			err = json.Unmarshal(message, &amp;amp;textMessage)
			if err != nil {
				s.log.ErrorF(&amp;quot;消息格式错误: %v&amp;quot;, err)
				break
			}

			switch textMessage.Type {
			 ...
			}
		}
	}
}

&lt;/code>&lt;/pre></description></item><item><title>Golang 简易WS服务 - 服务端</title><link>/post/2023/02/21/39/</link><pubDate>Tue, 21 Feb 2023 00:00:00 +0000</pubDate><guid>/post/2023/02/21/39/</guid><description>&lt;h2 id="本次开发主要使用了gorilla-websocket软件包">本次开发主要使用了Gorilla Websocket软件包&lt;/h2>
&lt;h3 id="客户端结构体">客户端结构体&lt;/h3>
&lt;p>维护socket连接，保存客户端信息&lt;/p>
&lt;h4 id="代码">代码&lt;/h4>
&lt;pre>&lt;code class="language-golang">package contorller

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/model&amp;quot;
	&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/enum&amp;quot;
	&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/logger&amp;quot;
	&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/response&amp;quot;
	&amp;quot;github.com/gorilla/websocket&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;time&amp;quot;
)

const (
	// pingWait is the maximum time in seconds to wait for a ping from
	pingWait = 20 * time.Second
	// Maximum message size allowed from peer.
	maxMessageSize = 512
)

type wsClient struct {
	manager *wsManager
	id string
	desc string
	conn *websocket.Conn
	status enum.ClientStatus
	send chan []byte
	isClosed chan bool
	lastPing time.Time
}

func newWsClient(manager *wsManager, conn *websocket.Conn, id, name, ip string) *wsClient {
	return &amp;amp;wsClient{
		manager: manager,
		id: id,
		desc: fmt.Sprintf(&amp;quot;客户端(%s, %s)&amp;quot;, name, ip),
		conn: conn,
		status: enum.ClientStatusOffline,
		send: make(chan []byte),
		isClosed: make(chan bool),
		lastPing: time.Now(),
	}
}

// Read 读取客户端发送过来的消息
func (c *wsClient) Read() {
	defer func() {
		c.unRegister()
		logger.Info(c.desc, &amp;quot;read协程退出&amp;quot;)
	}()

	c.conn.SetReadLimit(maxMessageSize)
	c.conn.SetPingHandler(func(text string) error {
		// 只需要知道客户端还活着就行，不需要回复
		c.lastPing = time.Now()
		// 更新客户端状态
		clientStatus, _ := strconv.ParseInt(text, 10, 32)
		c.status = enum.ClientStatus(int32(clientStatus))
		return nil
	})

	for {
		msgType, data, err := c.conn.ReadMessage()
		if err != nil {
			logger.Error(c.desc, &amp;quot;c.conn.ReadMessage&amp;quot;, err.Error())
			break
		}

		switch msgType {
		case websocket.TextMessage:
			var msg *model.WsMessage
			err = json.Unmarshal(data, &amp;amp;msg)
			if err != nil {
				logger.Error(c.desc, &amp;quot;json.Unmarshal&amp;quot;, err.Error())
				break
			}

			switch msg.Type {
			default:
				logger.Info(c.desc, &amp;quot;未知消息类型&amp;quot;, string(data))
				c.send &amp;lt;- data
			}
		}
	}
}

// Write 把对应消息写回客户端
func (c *wsClient) Write() {
	defer func() {
		logger.Info(c.desc, &amp;quot;write协程退出&amp;quot;)
		c.unRegister()
	}()
	for {
		select {
		case &amp;lt;-c.isClosed:
			return
		case msg := &amp;lt;-c.send:
			err := c.conn.WriteMessage(websocket.TextMessage, msg)
			if err != nil {
				logger.Error(c.desc, &amp;quot;c.conn.WriteMessage&amp;quot;, err.Error())
				return
			}
		}
	}
}

// Check 检测客户端是否超时
func (c *wsClient) Check() {
	defer func() {
		logger.Info(c.desc, &amp;quot;check协程退出&amp;quot;)
	}()
	ticker := time.NewTicker(pingWait / 6)
	for {
		select {
		case &amp;lt;-c.isClosed:
			return
		case &amp;lt;-ticker.C:
			// 主动关闭连接
			if time.Now().Sub(c.lastPing) &amp;gt; pingWait {
				response.WsReturnErr(c.conn, enum.WsDataErr, &amp;quot;客户端超时，主动关闭连接&amp;quot;)
				logger.Info(c.desc, &amp;quot;客户端超时，主动关闭连接&amp;quot;)
				return
			}
		}
	}
}

func (c *wsClient) unRegister() {
	if c.manager.clients[c.id] != nil {
		c.manager.unRegister &amp;lt;- c
	}
}

&lt;/code>&lt;/pre>
&lt;h4 id="使用">使用&lt;/h4>
&lt;p>应当在控制器/入口处&lt;/p></description></item><item><title>Golang 协程更好的进行错误处理</title><link>/post/2022/06/02/29/</link><pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate><guid>/post/2022/06/02/29/</guid><description>&lt;h2 id="利用-channel-来传输多个-goroutine-中的-errors">利用 &lt;code>channel&lt;/code> 来传输多个 goroutine 中的 errors&lt;/h2>
&lt;p>Go 的经典哲学：不要通过共享内存来通信，而是通过通信来实现内存共享&lt;/p>
&lt;pre>&lt;code class="language-golang">func main() {
	cherrors := make(chan error)
	wgDone := make(chan bool)

	var wg sync.WaitGroup
	wg.Add(2)
	go func() {
		//... 业务逻辑
		wg.Done()
	}()
	go func() {
		//... 业务逻辑
		err := returnErr()
		if err != nil {
			cherrors &amp;lt;- err
		}
		wg.Done()
	}()
	go func() {
		wg.Wait()
		close(wgDone)
	}()

	select {
	case &amp;lt;-wgDone:
		break
	case err := &amp;lt;-cherrors:
		close(cherrors)
		fmt.Println(err)
	}

	time.Sleep(time.Second)
}

func returnErr() error {
	return errors.New(&amp;quot;出错啦。。我是错误信息&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;h2 id="使用-syncerrgroup">使用 &lt;code>sync/errgroup&lt;/code>&lt;/h2>
&lt;p>使用官方提供的&lt;code>golang.org/x/sync/errgroup&lt;/code>标准库&lt;/p></description></item><item><title>Golang Defer理解</title><link>/post/2022/01/13/25/</link><pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate><guid>/post/2022/01/13/25/</guid><description>&lt;h3 id="结论">结论&lt;/h3>
&lt;ol>
&lt;li>多个defer的执行顺序为&lt;code>先进后出&lt;/code>&lt;/li>
&lt;li>匿名返回值是在&lt;code>return&lt;/code>执行时被声明，有名返回值则是在函数声明的同时被声明，因此在&lt;code>defer&lt;/code>语句中只能访问有名返回值，而不能直接访问匿名返回值&lt;/li>
&lt;li>&lt;code>return&lt;/code>其实应该包含前后两个步骤：第一步是给返回值赋值（若为有名返回值则直接赋值，若为匿名返回值则先声明再赋值）；第二步是调用&lt;code>RET&lt;/code>返回指令并传入返回值，而&lt;code>RET&lt;/code>则会检查&lt;code>defer&lt;/code>是否存在，若存在就先逆序插播defer语句，最后RET携带返回值退出函数&lt;/li>
&lt;li>延迟函数的参数在 defer 语句出现时就已经确定下来了（defer声明时会先计算确定参数的值，defer推迟执行的仅是其函数体）&lt;/li>
&lt;/ol>
&lt;h3 id="解释">解释&lt;/h3>
&lt;h5 id="结论1">结论1&lt;/h5>
&lt;pre>&lt;code class="language-golang">package main

func main() {
 for i := 0; i &amp;lt; 4; i++ {
 defer fmt.Print(i)
 }

 // Output:
 // 3
 // 2
 // 1
 // 0
}
&lt;/code>&lt;/pre>
&lt;h5 id="结论2和结论3">结论2和结论3&lt;/h5>
&lt;pre>&lt;code class="language-golang">package main

import (
 &amp;quot;fmt&amp;quot;
)

func main() {
 fmt.Println(a())

 // Output:
 // 1
 // 2
}

// 无名返回值
func a() int {
 defer func() { i++ }()
 return 1
}

// 有名返回值
func a() (i int) {
 defer func() { i++ }()
 return 1
}
&lt;/code>&lt;/pre>
&lt;h5 id="结论4">结论4&lt;/h5>
&lt;pre>&lt;code class="language-golang">package main

import (
 &amp;quot;fmt&amp;quot;
)

func main() {
 a()
 b()

 // Output:
 // 0
 // enter: b
 // in b
 // leave: b
}

func a() {
 i := 0
 defer fmt.Println(i) // 调用时i已经确定为0
 i++
 return
}

func trace(s string) s {
 fmt.Println(&amp;quot;enter: &amp;quot;, s)
 return s
}

func un(s) {
 fmt.Println(&amp;quot;leave: &amp;quot;, s)
}

func b() {
 defer un(trace(&amp;quot;b&amp;quot;)) // defer声明时会先计算确定参数的值，即执行了trace()，defer推迟执行的仅是其函数体un()
 fmt.Println(&amp;quot;in b&amp;quot;)
}
&lt;/code>&lt;/pre>
&lt;h3 id="参考">参考&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#53-defer">《Go语言设计与实现》&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/1410243">Golang中defer、return、返回值之间执行顺序的坑&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/huang_yong_peng/article/details/82950743">理解Golang中defer的使用&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Casbin 理解</title><link>/post/2021/12/31/24/</link><pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate><guid>/post/2021/12/31/24/</guid><description>&lt;h3 id="rbac">RBAC&lt;/h3>
&lt;p>model.conf&lt;/p>
&lt;pre>&lt;code class="language-conf">[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) &amp;amp;&amp;amp; r.obj == p.obj &amp;amp;&amp;amp; r.act == p.act
&lt;/code>&lt;/pre>
&lt;p>casbin_rule&lt;/p>
&lt;pre>&lt;code>p, alice, data1, read
p, bob, data2, write
p, data2_admin, data2, read
p, data2_admin, data2, write

g, alice, data2_admin
&lt;/code>&lt;/pre>
&lt;p>粗略将&lt;code>sub&lt;/code>可以理解为角色、用户，将&lt;code>obj&lt;/code>理解为资源，将&lt;code>act&lt;/code>理解为操作
当&lt;code>sub&lt;/code>为用户时，即用户直接对资源进行授权
当&lt;code>sub&lt;/code>为角色时，即用户分配有某角色，某角色对资源进行授权&lt;/p>
&lt;p>从上面的例子可以看出&lt;/p>
&lt;ol>
&lt;li>&lt;code>alice&lt;/code>被授予了对&lt;code>data1&lt;/code>资源的读权限&lt;/li>
&lt;li>&lt;code>bob&lt;/code>被授予了对&lt;code>data2&lt;/code>资源的写权限&lt;/li>
&lt;li>&lt;code>data2_admin&lt;/code>被授予了&lt;code>data2&lt;/code>的读写权限，我们可以把&lt;code>data2_admin&lt;/code>可以理解为角色&lt;/li>
&lt;li>将&lt;code>alice&lt;/code>分配有&lt;code>data2_admin&lt;/code>角色，则&lt;code>alice&lt;/code>此时具有对&lt;code>data2&lt;/code>的读写权限&lt;/li>
&lt;/ol>
&lt;p>p：&lt;code>用户、角色&lt;/code>对&lt;code>资源&lt;/code>的授权
g：将&lt;code>用户&lt;/code>分配有&lt;code>角色&lt;/code>组&lt;/p></description></item><item><title>Golang 通过通道控制携程数量</title><link>/post/2021/11/02/23/</link><pubDate>Tue, 02 Nov 2021 17:31:00 +0000</pubDate><guid>/post/2021/11/02/23/</guid><description>&lt;pre>&lt;code class="language-golang">func main() {
	var wg sync.WaitGroup
	var ch = make(chan bool, 10)
 for {
 wg.Add(1)
 ch &amp;lt;- true
 go func() {
 defer func() {
 &amp;lt;- ch
 wg.Done()
 }()
 // 逻辑
 ...
 }()
 }

 wg.Wait()
}
&lt;/code>&lt;/pre></description></item><item><title>Golang AES-128/GCM + BASE64 加密</title><link>/post/2021/03/15/14/</link><pubDate>Mon, 15 Mar 2021 00:00:00 +0000</pubDate><guid>/post/2021/03/15/14/</guid><description>&lt;p>需求背景：接入网络游戏防沉迷系统，其中请求体body需要进行加密，和签名&lt;/p>
&lt;h4 id="加密">加密&lt;/h4>
&lt;pre>&lt;code class="language-go">func GCMEncrypt(secretKey, originalText string) (string, error) {
	// 密钥需要解码
	key, _ := hex.DecodeString(secretKey)
	block, err := aes.NewCipher(key)
	if err != nil {
		return &amp;quot;&amp;quot;, err
	}

	aesGcm, err := cipher.NewGCM(block)
	if err != nil {
		return &amp;quot;&amp;quot;, err
	}
	
	// 向量
	nonce := make([]byte, aesGcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return &amp;quot;&amp;quot;, err
	}

	cipherText := aesGcm.Seal(nonce, nonce, []byte(originalText), nil)

	// encode as base64 string
	encoded := base64.StdEncoding.EncodeToString(cipherText)
	return encoded, nil
}
&lt;/code>&lt;/pre>
&lt;h4 id="签名">签名&lt;/h4>
&lt;pre>&lt;code class="language-go">func (s *encryptService) Sign(headers, body map[string]string) string {
	var data string
	var keys []string
	// key排序
	for k := range headers {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	// 拼接
	for _, k := range keys {
		data = data + k + headers[k]
	}
	data = s.appSecret + data + gconv.String(body)

	// 对字符串进行sha256哈希
	h := sha256.New()
	h.Write([]byte(data))
	sum := h.Sum(nil)
	return hex.EncodeToString(sum)
}
&lt;/code>&lt;/pre>
&lt;h4 id="使用">使用&lt;/h4>
&lt;pre>&lt;code class="language-go">// 参数初始化
headers := map[string]string{
	&amp;quot;appId&amp;quot;: &amp;quot;xxxxxxxx&amp;quot;,
	&amp;quot;bizId&amp;quot;: &amp;quot;xxxxxxxx&amp;quot;,
	&amp;quot;timestamps&amp;quot;: strconv.Itoa(int(time.Now().UnixNano() / 1e6)),
}
// 请求体加密
jsonByte, _ := json.Marshal(req)
cipher, _ := GCMEncrypt(string(jsonByte), 'xxxxxxxxx') // 第二个参数是密钥
body := map[string]string{
	&amp;quot;data&amp;quot;: cipher,
}
// 生成签名
headers[&amp;quot;sign&amp;quot;] = Encrypt.Sign(headers, body)
headers[&amp;quot;Content-Type&amp;quot;] = &amp;quot;application/json&amp;quot;
.....发http请求
&lt;/code>&lt;/pre></description></item><item><title>Laravel 契约和门面简单解读</title><link>/post/2020/03/30/11/</link><pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate><guid>/post/2020/03/30/11/</guid><description>&lt;p>最近笔者正在理解Larvael服务容器、服务提供者、门面、契约的关系。
今天主要是记录自己借Laravel自带的Cache模块进行一个讲解。&lt;/p>
&lt;h3 id="代码和流程">代码和流程&lt;/h3>
&lt;p>首先我们打开&lt;code>config\app.php&lt;/code>中&lt;code>providers&lt;/code>下有一个服务提供者&lt;code>Illuminate\Cache\CacheServiceProvider::class&lt;/code>&lt;br>
我们看看他的服务提供者是怎么写的：&lt;/p>
&lt;pre>&lt;code>public function register()
 {
 $this-&amp;gt;app-&amp;gt;singleton('cache', function ($app) {
 return new CacheManager($app);
 });

 $this-&amp;gt;app-&amp;gt;singleton('cache.store', function ($app) {
 return $app['cache']-&amp;gt;driver();
 });

 $this-&amp;gt;app-&amp;gt;singleton('cache.psr6', function ($app) {
 return new Psr16Adapter($app['cache.store']);
 });

 $this-&amp;gt;app-&amp;gt;singleton('memcached.connector', function () {
 return new MemcachedConnector;
 });
 }
&lt;/code>&lt;/pre>
&lt;p>我们主要看&lt;code>cache&lt;/code>这个门面，它所单例绑定的是&lt;code>CacheManager&lt;/code>，我们继续深入&lt;/p>
&lt;pre>&lt;code>&amp;lt;?php

namespace Illuminate\Cache;

use Aws\DynamoDb\DynamoDbClient;
use Closure;
use Illuminate\Contracts\Cache\Factory as FactoryContract;
use Illuminate\Contracts\Cache\Store;
use Illuminate\Contracts\Events\Dispatcher as DispatcherContract;
use Illuminate\Support\Arr;
use InvalidArgumentException;

/**
 * @mixin \Illuminate\Contracts\Cache\Repository
 */
class CacheManager implements FactoryContract
{
 /**
 * The application instance.
 *
 * @var \Illuminate\Contracts\Foundation\Application
 */
 protected $app;

 /**
 * The array of resolved cache stores.
 *
 * @var array
 */
 protected $stores = [];

 /**
 * The registered custom driver creators.
 *
 * @var array
 */
 protected $customCreators = [];

 /**
 * Create a new Cache manager instance.
 *
 * @param \Illuminate\Contracts\Foundation\Application $app
 * @return void
 */
 public function __construct($app)
 {
 $this-&amp;gt;app = $app;
 }

 /**
 * Get a cache store instance by name, wrapped in a repository.
 *
 * @param string|null $name
 * @return \Illuminate\Contracts\Cache\Repository
 */
 public function store($name = null)
 {
 $name = $name ?: $this-&amp;gt;getDefaultDriver();

 return $this-&amp;gt;stores[$name] = $this-&amp;gt;get($name);
 }

 /**
 * Get a cache driver instance.
 *
 * @param string|null $driver
 * @return \Illuminate\Contracts\Cache\Repository
 */
 public function driver($driver = null)
 {
 return $this-&amp;gt;store($driver);
 }

 /**
 * Attempt to get the store from the local cache.
 *
 * @param string $name
 * @return \Illuminate\Contracts\Cache\Repository
 */
 protected function get($name)
 {
 return $this-&amp;gt;stores[$name] ?? $this-&amp;gt;resolve($name);
 }

 /**
 * Resolve the given store.
 *
 * @param string $name
 * @return \Illuminate\Contracts\Cache\Repository
 *
 * @throws \InvalidArgumentException
 */
 protected function resolve($name)
 {
 $config = $this-&amp;gt;getConfig($name);

 if (is_null($config)) {
 throw new InvalidArgumentException(&amp;quot;Cache store [{$name}] is not defined.&amp;quot;);
 }

 if (isset($this-&amp;gt;customCreators[$config['driver']])) {
 return $this-&amp;gt;callCustomCreator($config);
 } else {
 $driverMethod = 'create'.ucfirst($config['driver']).'Driver';

 if (method_exists($this, $driverMethod)) {
 return $this-&amp;gt;{$driverMethod}($config);
 } else {
 throw new InvalidArgumentException(&amp;quot;Driver [{$config['driver']}] is not supported.&amp;quot;);
 }
 }
 }

 /**
 * Call a custom driver creator.
 *
 * @param array $config
 * @return mixed
 */
 protected function callCustomCreator(array $config)
 {
 return $this-&amp;gt;customCreators[$config['driver']]($this-&amp;gt;app, $config);
 }

 ......

 /**
 * Create an instance of the file cache driver.
 *
 * @param array $config
 * @return \Illuminate\Cache\Repository
 */
 protected function createFileDriver(array $config)
 {
 return $this-&amp;gt;repository(new FileStore($this-&amp;gt;app['files'], $config['path']));
 }

 /**
 * Create a new cache repository with the given implementation.
 *
 * @param \Illuminate\Contracts\Cache\Store $store
 * @return \Illuminate\Cache\Repository
 */
 public function repository(Store $store)
 {
 return tap(new Repository($store), function ($repository) {
 $this-&amp;gt;setEventDispatcher($repository);
 });
 }

 /**
 * Set the event dispatcher on the given repository instance.
 *
 * @param \Illuminate\Cache\Repository $repository
 * @return void
 */
 protected function setEventDispatcher(Repository $repository)
 {
 if (! $this-&amp;gt;app-&amp;gt;bound(DispatcherContract::class)) {
 return;
 }

 $repository-&amp;gt;setEventDispatcher(
 $this-&amp;gt;app[DispatcherContract::class]
 );
 }

 ......

 /**
 * Get the cache connection configuration.
 *
 * @param string $name
 * @return array
 */
 protected function getConfig($name)
 {
 return $this-&amp;gt;app['config'][&amp;quot;cache.stores.{$name}&amp;quot;];
 }

 ......

 /**
 * Dynamically call the default driver instance.
 *
 * @param string $method
 * @param array $parameters
 * @return mixed
 */
 public function __call($method, $parameters)
 {
 return $this-&amp;gt;store()-&amp;gt;$method(...$parameters);
 }
}

&lt;/code>&lt;/pre>
&lt;p>我们以Laravel默认的File存储讲起：&lt;/p></description></item></channel></rss>