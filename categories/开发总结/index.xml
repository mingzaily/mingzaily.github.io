<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开发总结 on 星河</title>
    <link>/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</link>
    <description>Recent content in 开发总结 on 星河</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 21 Feb 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang 简易WS服务 - 客户端</title>
      <link>/post/2023/02/21/42/</link>
      <pubDate>Tue, 21 Feb 2023 00:00:00 +0000</pubDate>
      <guid>/post/2023/02/21/42/</guid>
      <description>&lt;p&gt;客户端代码较为简单&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;&#xA;type SocketClient struct {&#xA;&#x9;host        string&#xA;&#x9;isClosed    chan bool&#xA;&#x9;log         *logger.Log // 自定义的log包&#xA;}&#xA;&#xA;type wsMessage struct {&#xA;&#x9;Type int         `json:&amp;quot;type&amp;quot;`&#xA;&#x9;Data interface{} `json:&amp;quot;data&amp;quot;`&#xA;}&#xA;&#xA;func NewSocketClient(configPath, logPath, host string) *SocketClient {&#xA;&#x9;w := io.MultiWriter(os.Stdout)&#xA;&#x9;if logPath != &amp;quot;&amp;quot; {&#xA;&#x9;&#x9;f, err := util.OpenFile(logPath)&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;panic(err)&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;w = io.MultiWriter(os.Stdout, f)&#xA;&#x9;}&#xA;&#xA;&#x9;return &amp;amp;SocketClient{&#xA;&#x9;&#x9;host:        host,&#xA;&#x9;&#x9;isClosed:    make(chan bool),&#xA;&#x9;&#x9;log:         logger.New(w, logger.LINFO, log.LstdFlags|log.Lmsgprefix),&#xA;&#x9;}&#xA;}&#xA;&#xA;func (s *SocketClient) Start() {&#xA;&#x9;// 设置在线&#xA;&#x9;ClientStatus = ClientStatusOnline&#xA;&#xA;&#x9;// 连接服务器&#xA;&#x9;u := url.URL{Scheme: &amp;quot;ws&amp;quot;, Host: s.host, Path: &amp;quot;/socket&amp;quot;}&#xA;&#x9;s.log.Info(&amp;quot;正在连接到&amp;quot;, u.String())&#xA;&#xA;&#x9;conn, _, err := websocket.DefaultDialer.Dial(u.String(), nil)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;s.log.ErrorF(&amp;quot;连接到服务器错误: %v&amp;quot;, err)&#xA;&#x9;}&#xA;&#x9;defer conn.Close()&#xA;&#xA;&#x9;s.log.Info(&amp;quot;已连接到服务器&amp;quot;)&#xA;&#xA;&#x9;interrupt := make(chan os.Signal, 1)&#xA;&#xA;&#x9;// 监听中断信号&#xA;&#x9;signal.Notify(interrupt, syscall.SIGKILL, syscall.SIGINT, syscall.SIGTERM, os.Kill)&#xA;&#x9;// 心跳包&#xA;&#x9;go s.pingHandler(conn)&#xA;&#x9;// 接收消息&#xA;&#x9;go s.receiveHandler(conn)&#xA;&#xA;&#x9;for {&#xA;&#x9;&#x9;select {&#xA;&#x9;&#x9;case &amp;lt;-interrupt:&#xA;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;收到SIGINT中断信号，正在关闭ws连接。。。&amp;quot;)&#xA;&#x9;&#x9;&#x9;_ = conn.WriteControl(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, &amp;quot;&amp;quot;), time.Now().Add(time.Second))&#xA;&#x9;&#x9;&#x9;select {&#xA;&#x9;&#x9;&#x9;case &amp;lt;-s.isClosed:&#xA;&#x9;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;WS链接已关闭，退出中。。。&amp;quot;)&#xA;&#x9;&#x9;&#x9;case &amp;lt;-time.After(time.Duration(1) * time.Second):&#xA;&#x9;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;关闭ws链接超时，退出中。。。&amp;quot;)&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;case &amp;lt;-s.isClosed:&#xA;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;ws链接已关闭，退出中。。。&amp;quot;)&#xA;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;func (s *SocketClient) pingHandler(conn *websocket.Conn) {&#xA;&#x9;ticker := time.NewTicker(pingTime)&#xA;&#x9;for {&#xA;&#x9;&#x9;select {&#xA;&#x9;&#x9;case &amp;lt;-ticker.C:&#xA;&#x9;&#x9;&#x9;status := strconv.FormatInt(int64(ClientStatus), 10)&#xA;&#x9;&#x9;&#x9;err := conn.WriteMessage(websocket.PingMessage, []byte(status))&#xA;&#x9;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;&#x9;s.log.ErrorF(&amp;quot;发送心跳包错误: %v&amp;quot;, err)&#xA;&#x9;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;case &amp;lt;-s.isClosed:&#xA;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;func (s *SocketClient) receiveHandler(ws *websocket.Conn) {&#xA;&#x9;defer close(s.isClosed)&#xA;&#x9;for {&#xA;&#x9;&#x9;messageType, message, err := ws.ReadMessage()&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;s.log.ErrorF(&amp;quot;读取消息 %v&amp;quot;, err)&#xA;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;switch messageType {&#xA;&#x9;&#x9;case websocket.TextMessage:&#xA;&#x9;&#x9;&#x9;var textMessage *wsMessage&#xA;&#xA;&#x9;&#x9;&#x9;err = json.Unmarshal(message, &amp;amp;textMessage)&#xA;&#x9;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;&#x9;s.log.ErrorF(&amp;quot;消息格式错误: %v&amp;quot;, err)&#xA;&#x9;&#x9;&#x9;&#x9;break&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;switch textMessage.Type {&#xA;&#x9;&#x9;&#x9;        ...&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Golang 简易WS服务 - 服务端</title>
      <link>/post/2023/02/21/39/</link>
      <pubDate>Tue, 21 Feb 2023 00:00:00 +0000</pubDate>
      <guid>/post/2023/02/21/39/</guid>
      <description>&lt;h2 id=&#34;本次开发主要使用了gorilla-websocket软件包&#34;&gt;本次开发主要使用了Gorilla Websocket软件包&lt;/h2&gt;&#xA;&lt;h3 id=&#34;客户端结构体&#34;&gt;客户端结构体&lt;/h3&gt;&#xA;&lt;p&gt;维护socket连接，保存客户端信息&lt;/p&gt;&#xA;&lt;h4 id=&#34;代码&#34;&gt;代码&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package contorller&#xA;&#xA;import (&#xA;&#x9;&amp;quot;encoding/json&amp;quot;&#xA;&#x9;&amp;quot;fmt&amp;quot;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/model&amp;quot;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/enum&amp;quot;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/logger&amp;quot;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/response&amp;quot;&#xA;&#x9;&amp;quot;github.com/gorilla/websocket&amp;quot;&#xA;&#x9;&amp;quot;strconv&amp;quot;&#xA;&#x9;&amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;const (&#xA;&#x9;// pingWait is the maximum time in seconds to wait for a ping from&#xA;&#x9;pingWait = 20 * time.Second&#xA;&#x9;// Maximum message size allowed from peer.&#xA;&#x9;maxMessageSize = 512&#xA;)&#xA;&#xA;type wsClient struct {&#xA;&#x9;manager  *wsManager&#xA;&#x9;id       string&#xA;&#x9;desc     string&#xA;&#x9;conn     *websocket.Conn&#xA;&#x9;status   enum.ClientStatus&#xA;&#x9;send     chan []byte&#xA;&#x9;isClosed chan bool&#xA;&#x9;lastPing time.Time&#xA;}&#xA;&#xA;func newWsClient(manager *wsManager, conn *websocket.Conn, id, name, ip string) *wsClient {&#xA;&#x9;return &amp;amp;wsClient{&#xA;&#x9;&#x9;manager:  manager,&#xA;&#x9;&#x9;id:       id,&#xA;&#x9;&#x9;desc:     fmt.Sprintf(&amp;quot;客户端(%s, %s)&amp;quot;, name, ip),&#xA;&#x9;&#x9;conn:     conn,&#xA;&#x9;&#x9;status:   enum.ClientStatusOffline,&#xA;&#x9;&#x9;send:     make(chan []byte),&#xA;&#x9;&#x9;isClosed: make(chan bool),&#xA;&#x9;&#x9;lastPing: time.Now(),&#xA;&#x9;}&#xA;}&#xA;&#xA;// Read 读取客户端发送过来的消息&#xA;func (c *wsClient) Read() {&#xA;&#x9;defer func() {&#xA;&#x9;&#x9;c.unRegister()&#xA;&#x9;&#x9;logger.Info(c.desc, &amp;quot;read协程退出&amp;quot;)&#xA;&#x9;}()&#xA;&#xA;&#x9;c.conn.SetReadLimit(maxMessageSize)&#xA;&#x9;c.conn.SetPingHandler(func(text string) error {&#xA;&#x9;&#x9;// 只需要知道客户端还活着就行，不需要回复&#xA;&#x9;&#x9;c.lastPing = time.Now()&#xA;&#x9;&#x9;// 更新客户端状态&#xA;&#x9;&#x9;clientStatus, _ := strconv.ParseInt(text, 10, 32)&#xA;&#x9;&#x9;c.status = enum.ClientStatus(int32(clientStatus))&#xA;&#x9;&#x9;return nil&#xA;&#x9;})&#xA;&#xA;&#x9;for {&#xA;&#x9;&#x9;msgType, data, err := c.conn.ReadMessage()&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;logger.Error(c.desc, &amp;quot;c.conn.ReadMessage&amp;quot;, err.Error())&#xA;&#x9;&#x9;&#x9;break&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;switch msgType {&#xA;&#x9;&#x9;case websocket.TextMessage:&#xA;&#x9;&#x9;&#x9;var msg *model.WsMessage&#xA;&#x9;&#x9;&#x9;err = json.Unmarshal(data, &amp;amp;msg)&#xA;&#x9;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;&#x9;logger.Error(c.desc, &amp;quot;json.Unmarshal&amp;quot;, err.Error())&#xA;&#x9;&#x9;&#x9;&#x9;break&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;switch msg.Type {&#xA;&#x9;&#x9;&#x9;default:&#xA;&#x9;&#x9;&#x9;&#x9;logger.Info(c.desc, &amp;quot;未知消息类型&amp;quot;, string(data))&#xA;&#x9;&#x9;&#x9;&#x9;c.send &amp;lt;- data&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;// Write 把对应消息写回客户端&#xA;func (c *wsClient) Write() {&#xA;&#x9;defer func() {&#xA;&#x9;&#x9;logger.Info(c.desc, &amp;quot;write协程退出&amp;quot;)&#xA;&#x9;&#x9;c.unRegister()&#xA;&#x9;}()&#xA;&#x9;for {&#xA;&#x9;&#x9;select {&#xA;&#x9;&#x9;case &amp;lt;-c.isClosed:&#xA;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;case msg := &amp;lt;-c.send:&#xA;&#x9;&#x9;&#x9;err := c.conn.WriteMessage(websocket.TextMessage, msg)&#xA;&#x9;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;&#x9;logger.Error(c.desc, &amp;quot;c.conn.WriteMessage&amp;quot;, err.Error())&#xA;&#x9;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;// Check 检测客户端是否超时&#xA;func (c *wsClient) Check() {&#xA;&#x9;defer func() {&#xA;&#x9;&#x9;logger.Info(c.desc, &amp;quot;check协程退出&amp;quot;)&#xA;&#x9;}()&#xA;&#x9;ticker := time.NewTicker(pingWait / 6)&#xA;&#x9;for {&#xA;&#x9;&#x9;select {&#xA;&#x9;&#x9;case &amp;lt;-c.isClosed:&#xA;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;case &amp;lt;-ticker.C:&#xA;&#x9;&#x9;&#x9;// 主动关闭连接&#xA;&#x9;&#x9;&#x9;if time.Now().Sub(c.lastPing) &amp;gt; pingWait {&#xA;&#x9;&#x9;&#x9;&#x9;response.WsReturnErr(c.conn, enum.WsDataErr, &amp;quot;客户端超时，主动关闭连接&amp;quot;)&#xA;&#x9;&#x9;&#x9;&#x9;logger.Info(c.desc, &amp;quot;客户端超时，主动关闭连接&amp;quot;)&#xA;&#x9;&#x9;&#x9;&#x9;return&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;func (c *wsClient) unRegister() {&#xA;&#x9;if c.manager.clients[c.id] != nil {&#xA;&#x9;&#x9;c.manager.unRegister &amp;lt;- c&#xA;&#x9;}&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;&#xA;&lt;p&gt;应当在控制器/入口处&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 协程更好的进行错误处理</title>
      <link>/post/2022/06/02/29/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      <guid>/post/2022/06/02/29/</guid>
      <description>&lt;h2 id=&#34;利用-channel-来传输多个-goroutine-中的-errors&#34;&gt;利用 &lt;code&gt;channel&lt;/code&gt; 来传输多个 goroutine 中的 errors&lt;/h2&gt;&#xA;&lt;p&gt;Go 的经典哲学：不要通过共享内存来通信，而是通过通信来实现内存共享&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {&#xA;&#x9;cherrors := make(chan error)&#xA;&#x9;wgDone := make(chan bool)&#xA;&#xA;&#x9;var wg sync.WaitGroup&#xA;&#x9;wg.Add(2)&#xA;&#x9;go func() {&#xA;&#x9;&#x9;//... 业务逻辑&#xA;&#x9;&#x9;wg.Done()&#xA;&#x9;}()&#xA;&#x9;go func() {&#xA;&#x9;&#x9;//... 业务逻辑&#xA;&#x9;&#x9;err := returnErr()&#xA;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;cherrors &amp;lt;- err&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;wg.Done()&#xA;&#x9;}()&#xA;&#x9;go func() {&#xA;&#x9;&#x9;wg.Wait()&#xA;&#x9;&#x9;close(wgDone)&#xA;&#x9;}()&#xA;&#xA;&#x9;select {&#xA;&#x9;case &amp;lt;-wgDone:&#xA;&#x9;&#x9;break&#xA;&#x9;case err := &amp;lt;-cherrors:&#xA;&#x9;&#x9;close(cherrors)&#xA;&#x9;&#x9;fmt.Println(err)&#xA;&#x9;}&#xA;&#xA;&#x9;time.Sleep(time.Second)&#xA;}&#xA;&#xA;func returnErr() error {&#xA;&#x9;return errors.New(&amp;quot;出错啦。。我是错误信息&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;使用-syncerrgroup&#34;&gt;使用 &lt;code&gt;sync/errgroup&lt;/code&gt;&lt;/h2&gt;&#xA;&lt;p&gt;使用官方提供的&lt;code&gt;golang.org/x/sync/errgroup&lt;/code&gt;标准库&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang Defer理解</title>
      <link>/post/2022/01/13/25/</link>
      <pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate>
      <guid>/post/2022/01/13/25/</guid>
      <description>&lt;h3 id=&#34;结论&#34;&gt;结论&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;多个defer的执行顺序为&lt;code&gt;先进后出&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;匿名返回值是在&lt;code&gt;return&lt;/code&gt;执行时被声明，有名返回值则是在函数声明的同时被声明，因此在&lt;code&gt;defer&lt;/code&gt;语句中只能访问有名返回值，而不能直接访问匿名返回值&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;return&lt;/code&gt;其实应该包含前后两个步骤：第一步是给返回值赋值（若为有名返回值则直接赋值，若为匿名返回值则先声明再赋值）；第二步是调用&lt;code&gt;RET&lt;/code&gt;返回指令并传入返回值，而&lt;code&gt;RET&lt;/code&gt;则会检查&lt;code&gt;defer&lt;/code&gt;是否存在，若存在就先逆序插播defer语句，最后RET携带返回值退出函数&lt;/li&gt;&#xA;&lt;li&gt;延迟函数的参数在 defer 语句出现时就已经确定下来了（defer声明时会先计算确定参数的值，defer推迟执行的仅是其函数体）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;解释&#34;&gt;解释&lt;/h3&gt;&#xA;&lt;h5 id=&#34;结论1&#34;&gt;结论1&lt;/h5&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xA;&#xA;func main() {&#xA;    for i := 0; i &amp;lt; 4; i++ {&#xA;        defer fmt.Print(i)&#xA;    }&#xA;&#xA;    // Output:&#xA;    // 3&#xA;    // 2&#xA;    // 1&#xA;    // 0&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h5 id=&#34;结论2和结论3&#34;&gt;结论2和结论3&lt;/h5&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    fmt.Println(a())&#xA;&#xA;    // Output:&#xA;    // 1&#xA;    // 2&#xA;}&#xA;&#xA;// 无名返回值&#xA;func a() int {&#xA;    defer func() { i++ }()&#xA;    return 1&#xA;}&#xA;&#xA;// 有名返回值&#xA;func a() (i int) {&#xA;    defer func() { i++ }()&#xA;    return 1&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h5 id=&#34;结论4&#34;&gt;结论4&lt;/h5&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;)&#xA;&#xA;func main() {&#xA;    a()&#xA;    b()&#xA;&#xA;    // Output:&#xA;    // 0&#xA;    // enter: b&#xA;    // in b&#xA;    // leave: b&#xA;}&#xA;&#xA;func a() {&#xA;    i := 0&#xA;    defer fmt.Println(i) // 调用时i已经确定为0&#xA;    i++&#xA;    return&#xA;}&#xA;&#xA;func trace(s string) s {&#xA;    fmt.Println(&amp;quot;enter: &amp;quot;, s)&#xA;    return s&#xA;}&#xA;&#xA;func un(s) {&#xA;    fmt.Println(&amp;quot;leave: &amp;quot;, s)&#xA;}&#xA;&#xA;func b() {&#xA;    defer un(trace(&amp;quot;b&amp;quot;)) // defer声明时会先计算确定参数的值，即执行了trace()，defer推迟执行的仅是其函数体un()&#xA;    fmt.Println(&amp;quot;in b&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#53-defer&#34;&gt;《Go语言设计与实现》&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1410243&#34;&gt;Golang中defer、return、返回值之间执行顺序的坑&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/huang_yong_peng/article/details/82950743&#34;&gt;理解Golang中defer的使用&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Casbin 理解</title>
      <link>/post/2021/12/31/24/</link>
      <pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/12/31/24/</guid>
      <description>&lt;h3 id=&#34;rbac&#34;&gt;RBAC&lt;/h3&gt;&#xA;&lt;p&gt;model.conf&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;[request_definition]&#xA;r = sub, obj, act&#xA;&#xA;[policy_definition]&#xA;p = sub, obj, act&#xA;&#xA;[role_definition]&#xA;g = _, _&#xA;&#xA;[policy_effect]&#xA;e = some(where (p.eft == allow))&#xA;&#xA;[matchers]&#xA;m = g(r.sub, p.sub) &amp;amp;&amp;amp; r.obj == p.obj &amp;amp;&amp;amp; r.act == p.act&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;casbin_rule&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;p, alice, data1, read&#xA;p, bob, data2, write&#xA;p, data2_admin, data2, read&#xA;p, data2_admin, data2, write&#xA;&#xA;g, alice, data2_admin&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;粗略将&lt;code&gt;sub&lt;/code&gt;可以理解为角色、用户，将&lt;code&gt;obj&lt;/code&gt;理解为资源，将&lt;code&gt;act&lt;/code&gt;理解为操作&#xA;当&lt;code&gt;sub&lt;/code&gt;为用户时，即用户直接对资源进行授权&#xA;当&lt;code&gt;sub&lt;/code&gt;为角色时，即用户分配有某角色，某角色对资源进行授权&lt;/p&gt;&#xA;&lt;p&gt;从上面的例子可以看出&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;alice&lt;/code&gt;被授予了对&lt;code&gt;data1&lt;/code&gt;资源的读权限&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;bob&lt;/code&gt;被授予了对&lt;code&gt;data2&lt;/code&gt;资源的写权限&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;data2_admin&lt;/code&gt;被授予了&lt;code&gt;data2&lt;/code&gt;的读写权限，我们可以把&lt;code&gt;data2_admin&lt;/code&gt;可以理解为角色&lt;/li&gt;&#xA;&lt;li&gt;将&lt;code&gt;alice&lt;/code&gt;分配有&lt;code&gt;data2_admin&lt;/code&gt;角色，则&lt;code&gt;alice&lt;/code&gt;此时具有对&lt;code&gt;data2&lt;/code&gt;的读写权限&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;p：&lt;code&gt;用户、角色&lt;/code&gt;对&lt;code&gt;资源&lt;/code&gt;的授权&#xA;g：将&lt;code&gt;用户&lt;/code&gt;分配有&lt;code&gt;角色&lt;/code&gt;组&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 通过通道控制携程数量</title>
      <link>/post/2021/11/02/23/</link>
      <pubDate>Tue, 02 Nov 2021 17:31:00 +0000</pubDate>
      <guid>/post/2021/11/02/23/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {&#xA;&#x9;var wg sync.WaitGroup&#xA;&#x9;var ch = make(chan bool, 10)&#xA;    for {&#xA;        wg.Add(1)&#xA;        ch &amp;lt;- true&#xA;        go func() {&#xA;            defer func() {&#xA;                &amp;lt;- ch&#xA;                wg.Done()&#xA;            }()&#xA;            // 逻辑&#xA;            ...&#xA;        }()&#xA;    }&#xA;&#xA;    wg.Wait()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Golang AES-128/GCM &#43; BASE64 加密</title>
      <link>/post/2021/03/15/14/</link>
      <pubDate>Mon, 15 Mar 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/03/15/14/</guid>
      <description>&lt;p&gt;需求背景：接入网络游戏防沉迷系统，其中请求体body需要进行加密，和签名&lt;/p&gt;&#xA;&lt;h4 id=&#34;加密&#34;&gt;加密&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func GCMEncrypt(secretKey, originalText string) (string, error) {&#xA;&#x9;// 密钥需要解码&#xA;&#x9;key, _ := hex.DecodeString(secretKey)&#xA;&#x9;block, err := aes.NewCipher(key)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, err&#xA;&#x9;}&#xA;&#xA;&#x9;aesGcm, err := cipher.NewGCM(block)&#xA;&#x9;if err != nil {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, err&#xA;&#x9;}&#xA;&#x9;&#xA;&#x9;// 向量&#xA;&#x9;nonce := make([]byte, aesGcm.NonceSize())&#xA;&#x9;if _, err := io.ReadFull(rand.Reader, nonce); err != nil {&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, err&#xA;&#x9;}&#xA;&#xA;&#x9;cipherText := aesGcm.Seal(nonce, nonce, []byte(originalText), nil)&#xA;&#xA;&#x9;// encode as base64 string&#xA;&#x9;encoded := base64.StdEncoding.EncodeToString(cipherText)&#xA;&#x9;return encoded, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;签名&#34;&gt;签名&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (s *encryptService) Sign(headers, body map[string]string) string {&#xA;&#x9;var data string&#xA;&#x9;var keys []string&#xA;&#x9;// key排序&#xA;&#x9;for k := range headers {&#xA;&#x9;&#x9;keys = append(keys, k)&#xA;&#x9;}&#xA;&#x9;sort.Strings(keys)&#xA;&#xA;&#x9;// 拼接&#xA;&#x9;for _, k := range keys {&#xA;&#x9;&#x9;data = data + k + headers[k]&#xA;&#x9;}&#xA;&#x9;data = s.appSecret + data + gconv.String(body)&#xA;&#xA;&#x9;// 对字符串进行sha256哈希&#xA;&#x9;h := sha256.New()&#xA;&#x9;h.Write([]byte(data))&#xA;&#x9;sum := h.Sum(nil)&#xA;&#x9;return hex.EncodeToString(sum)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 参数初始化&#xA;headers := map[string]string{&#xA;&#x9;&amp;quot;appId&amp;quot;:      &amp;quot;xxxxxxxx&amp;quot;,&#xA;&#x9;&amp;quot;bizId&amp;quot;:      &amp;quot;xxxxxxxx&amp;quot;,&#xA;&#x9;&amp;quot;timestamps&amp;quot;: strconv.Itoa(int(time.Now().UnixNano() / 1e6)),&#xA;}&#xA;// 请求体加密&#xA;jsonByte, _ := json.Marshal(req)&#xA;cipher, _ := GCMEncrypt(string(jsonByte), &#39;xxxxxxxxx&#39;) // 第二个参数是密钥&#xA;body := map[string]string{&#xA;&#x9;&amp;quot;data&amp;quot;: cipher,&#xA;}&#xA;// 生成签名&#xA;headers[&amp;quot;sign&amp;quot;] = Encrypt.Sign(headers, body)&#xA;headers[&amp;quot;Content-Type&amp;quot;] = &amp;quot;application/json&amp;quot;&#xA;.....发http请求&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Laravel 契约和门面简单解读</title>
      <link>/post/2020/03/30/11/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate>
      <guid>/post/2020/03/30/11/</guid>
      <description>&lt;p&gt;最近笔者正在理解Larvael服务容器、服务提供者、门面、契约的关系。&#xA;今天主要是记录自己借Laravel自带的Cache模块进行一个讲解。&lt;/p&gt;&#xA;&lt;h3 id=&#34;代码和流程&#34;&gt;代码和流程&lt;/h3&gt;&#xA;&lt;p&gt;首先我们打开&lt;code&gt;config\app.php&lt;/code&gt;中&lt;code&gt;providers&lt;/code&gt;下有一个服务提供者&lt;code&gt;Illuminate\Cache\CacheServiceProvider::class&lt;/code&gt;&lt;br&gt;&#xA;我们看看他的服务提供者是怎么写的：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public function register()&#xA;    {&#xA;        $this-&amp;gt;app-&amp;gt;singleton(&#39;cache&#39;, function ($app) {&#xA;            return new CacheManager($app);&#xA;        });&#xA;&#xA;        $this-&amp;gt;app-&amp;gt;singleton(&#39;cache.store&#39;, function ($app) {&#xA;            return $app[&#39;cache&#39;]-&amp;gt;driver();&#xA;        });&#xA;&#xA;        $this-&amp;gt;app-&amp;gt;singleton(&#39;cache.psr6&#39;, function ($app) {&#xA;            return new Psr16Adapter($app[&#39;cache.store&#39;]);&#xA;        });&#xA;&#xA;        $this-&amp;gt;app-&amp;gt;singleton(&#39;memcached.connector&#39;, function () {&#xA;            return new MemcachedConnector;&#xA;        });&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;我们主要看&lt;code&gt;cache&lt;/code&gt;这个门面，它所单例绑定的是&lt;code&gt;CacheManager&lt;/code&gt;，我们继续深入&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?php&#xA;&#xA;namespace Illuminate\Cache;&#xA;&#xA;use Aws\DynamoDb\DynamoDbClient;&#xA;use Closure;&#xA;use Illuminate\Contracts\Cache\Factory as FactoryContract;&#xA;use Illuminate\Contracts\Cache\Store;&#xA;use Illuminate\Contracts\Events\Dispatcher as DispatcherContract;&#xA;use Illuminate\Support\Arr;&#xA;use InvalidArgumentException;&#xA;&#xA;/**&#xA; * @mixin \Illuminate\Contracts\Cache\Repository&#xA; */&#xA;class CacheManager implements FactoryContract&#xA;{&#xA;    /**&#xA;     * The application instance.&#xA;     *&#xA;     * @var \Illuminate\Contracts\Foundation\Application&#xA;     */&#xA;    protected $app;&#xA;&#xA;    /**&#xA;     * The array of resolved cache stores.&#xA;     *&#xA;     * @var array&#xA;     */&#xA;    protected $stores = [];&#xA;&#xA;    /**&#xA;     * The registered custom driver creators.&#xA;     *&#xA;     * @var array&#xA;     */&#xA;    protected $customCreators = [];&#xA;&#xA;    /**&#xA;     * Create a new Cache manager instance.&#xA;     *&#xA;     * @param  \Illuminate\Contracts\Foundation\Application  $app&#xA;     * @return void&#xA;     */&#xA;    public function __construct($app)&#xA;    {&#xA;        $this-&amp;gt;app = $app;&#xA;    }&#xA;&#xA;    /**&#xA;     * Get a cache store instance by name, wrapped in a repository.&#xA;     *&#xA;     * @param  string|null  $name&#xA;     * @return \Illuminate\Contracts\Cache\Repository&#xA;     */&#xA;    public function store($name = null)&#xA;    {&#xA;        $name = $name ?: $this-&amp;gt;getDefaultDriver();&#xA;&#xA;        return $this-&amp;gt;stores[$name] = $this-&amp;gt;get($name);&#xA;    }&#xA;&#xA;    /**&#xA;     * Get a cache driver instance.&#xA;     *&#xA;     * @param  string|null  $driver&#xA;     * @return \Illuminate\Contracts\Cache\Repository&#xA;     */&#xA;    public function driver($driver = null)&#xA;    {&#xA;        return $this-&amp;gt;store($driver);&#xA;    }&#xA;&#xA;    /**&#xA;     * Attempt to get the store from the local cache.&#xA;     *&#xA;     * @param  string  $name&#xA;     * @return \Illuminate\Contracts\Cache\Repository&#xA;     */&#xA;    protected function get($name)&#xA;    {&#xA;        return $this-&amp;gt;stores[$name] ?? $this-&amp;gt;resolve($name);&#xA;    }&#xA;&#xA;    /**&#xA;     * Resolve the given store.&#xA;     *&#xA;     * @param  string  $name&#xA;     * @return \Illuminate\Contracts\Cache\Repository&#xA;     *&#xA;     * @throws \InvalidArgumentException&#xA;     */&#xA;    protected function resolve($name)&#xA;    {&#xA;        $config = $this-&amp;gt;getConfig($name);&#xA;&#xA;        if (is_null($config)) {&#xA;            throw new InvalidArgumentException(&amp;quot;Cache store [{$name}] is not defined.&amp;quot;);&#xA;        }&#xA;&#xA;        if (isset($this-&amp;gt;customCreators[$config[&#39;driver&#39;]])) {&#xA;            return $this-&amp;gt;callCustomCreator($config);&#xA;        } else {&#xA;            $driverMethod = &#39;create&#39;.ucfirst($config[&#39;driver&#39;]).&#39;Driver&#39;;&#xA;&#xA;            if (method_exists($this, $driverMethod)) {&#xA;                return $this-&amp;gt;{$driverMethod}($config);&#xA;            } else {&#xA;                throw new InvalidArgumentException(&amp;quot;Driver [{$config[&#39;driver&#39;]}] is not supported.&amp;quot;);&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    /**&#xA;     * Call a custom driver creator.&#xA;     *&#xA;     * @param  array  $config&#xA;     * @return mixed&#xA;     */&#xA;    protected function callCustomCreator(array $config)&#xA;    {&#xA;        return $this-&amp;gt;customCreators[$config[&#39;driver&#39;]]($this-&amp;gt;app, $config);&#xA;    }&#xA;&#xA;    ......&#xA;&#xA;    /**&#xA;     * Create an instance of the file cache driver.&#xA;     *&#xA;     * @param  array  $config&#xA;     * @return \Illuminate\Cache\Repository&#xA;     */&#xA;    protected function createFileDriver(array $config)&#xA;    {&#xA;        return $this-&amp;gt;repository(new FileStore($this-&amp;gt;app[&#39;files&#39;], $config[&#39;path&#39;]));&#xA;    }&#xA;&#xA;    /**&#xA;     * Create a new cache repository with the given implementation.&#xA;     *&#xA;     * @param  \Illuminate\Contracts\Cache\Store  $store&#xA;     * @return \Illuminate\Cache\Repository&#xA;     */&#xA;    public function repository(Store $store)&#xA;    {&#xA;        return tap(new Repository($store), function ($repository) {&#xA;            $this-&amp;gt;setEventDispatcher($repository);&#xA;        });&#xA;    }&#xA;&#xA;    /**&#xA;     * Set the event dispatcher on the given repository instance.&#xA;     *&#xA;     * @param  \Illuminate\Cache\Repository  $repository&#xA;     * @return void&#xA;     */&#xA;    protected function setEventDispatcher(Repository $repository)&#xA;    {&#xA;        if (! $this-&amp;gt;app-&amp;gt;bound(DispatcherContract::class)) {&#xA;            return;&#xA;        }&#xA;&#xA;        $repository-&amp;gt;setEventDispatcher(&#xA;            $this-&amp;gt;app[DispatcherContract::class]&#xA;        );&#xA;    }&#xA;&#xA;    ......&#xA;&#xA;    /**&#xA;     * Get the cache connection configuration.&#xA;     *&#xA;     * @param  string  $name&#xA;     * @return array&#xA;     */&#xA;    protected function getConfig($name)&#xA;    {&#xA;        return $this-&amp;gt;app[&#39;config&#39;][&amp;quot;cache.stores.{$name}&amp;quot;];&#xA;    }&#xA;&#xA;    ......&#xA;&#xA;    /**&#xA;     * Dynamically call the default driver instance.&#xA;     *&#xA;     * @param  string  $method&#xA;     * @param  array  $parameters&#xA;     * @return mixed&#xA;     */&#xA;    public function __call($method, $parameters)&#xA;    {&#xA;        return $this-&amp;gt;store()-&amp;gt;$method(...$parameters);&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;我们以Laravel默认的File存储讲起：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
