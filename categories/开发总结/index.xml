<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开发总结 on 星河</title>
    <link>/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</link>
    <description>Recent content in 开发总结 on 星河</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 21 Feb 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="/categories/%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang 简易WS服务 - 客户端</title>
      <link>/post/2023/02/21/42/</link>
      <pubDate>Tue, 21 Feb 2023 00:00:00 +0000</pubDate>
      <guid>/post/2023/02/21/42/</guid>
      <description>&lt;p&gt;客户端代码较为简单&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;&#xD;&#xA;type SocketClient struct {&#xD;&#xA;&#x9;host        string&#xD;&#xA;&#x9;isClosed    chan bool&#xD;&#xA;&#x9;log         *logger.Log // 自定义的log包&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;type wsMessage struct {&#xD;&#xA;&#x9;Type int         `json:&amp;quot;type&amp;quot;`&#xD;&#xA;&#x9;Data interface{} `json:&amp;quot;data&amp;quot;`&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func NewSocketClient(configPath, logPath, host string) *SocketClient {&#xD;&#xA;&#x9;w := io.MultiWriter(os.Stdout)&#xD;&#xA;&#x9;if logPath != &amp;quot;&amp;quot; {&#xD;&#xA;&#x9;&#x9;f, err := util.OpenFile(logPath)&#xD;&#xA;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;panic(err)&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;w = io.MultiWriter(os.Stdout, f)&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;return &amp;amp;SocketClient{&#xD;&#xA;&#x9;&#x9;host:        host,&#xD;&#xA;&#x9;&#x9;isClosed:    make(chan bool),&#xD;&#xA;&#x9;&#x9;log:         logger.New(w, logger.LINFO, log.LstdFlags|log.Lmsgprefix),&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func (s *SocketClient) Start() {&#xD;&#xA;&#x9;// 设置在线&#xD;&#xA;&#x9;ClientStatus = ClientStatusOnline&#xD;&#xA;&#xD;&#xA;&#x9;// 连接服务器&#xD;&#xA;&#x9;u := url.URL{Scheme: &amp;quot;ws&amp;quot;, Host: s.host, Path: &amp;quot;/socket&amp;quot;}&#xD;&#xA;&#x9;s.log.Info(&amp;quot;正在连接到&amp;quot;, u.String())&#xD;&#xA;&#xD;&#xA;&#x9;conn, _, err := websocket.DefaultDialer.Dial(u.String(), nil)&#xD;&#xA;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;s.log.ErrorF(&amp;quot;连接到服务器错误: %v&amp;quot;, err)&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;defer conn.Close()&#xD;&#xA;&#xD;&#xA;&#x9;s.log.Info(&amp;quot;已连接到服务器&amp;quot;)&#xD;&#xA;&#xD;&#xA;&#x9;interrupt := make(chan os.Signal, 1)&#xD;&#xA;&#xD;&#xA;&#x9;// 监听中断信号&#xD;&#xA;&#x9;signal.Notify(interrupt, syscall.SIGKILL, syscall.SIGINT, syscall.SIGTERM, os.Kill)&#xD;&#xA;&#x9;// 心跳包&#xD;&#xA;&#x9;go s.pingHandler(conn)&#xD;&#xA;&#x9;// 接收消息&#xD;&#xA;&#x9;go s.receiveHandler(conn)&#xD;&#xA;&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;case &amp;lt;-interrupt:&#xD;&#xA;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;收到SIGINT中断信号，正在关闭ws连接。。。&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;_ = conn.WriteControl(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, &amp;quot;&amp;quot;), time.Now().Add(time.Second))&#xD;&#xA;&#x9;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;&#x9;case &amp;lt;-s.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;WS链接已关闭，退出中。。。&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;case &amp;lt;-time.After(time.Duration(1) * time.Second):&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;关闭ws链接超时，退出中。。。&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;case &amp;lt;-s.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;s.log.Info(&amp;quot;ws链接已关闭，退出中。。。&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func (s *SocketClient) pingHandler(conn *websocket.Conn) {&#xD;&#xA;&#x9;ticker := time.NewTicker(pingTime)&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;case &amp;lt;-ticker.C:&#xD;&#xA;&#x9;&#x9;&#x9;status := strconv.FormatInt(int64(ClientStatus), 10)&#xD;&#xA;&#x9;&#x9;&#x9;err := conn.WriteMessage(websocket.PingMessage, []byte(status))&#xD;&#xA;&#x9;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;s.log.ErrorF(&amp;quot;发送心跳包错误: %v&amp;quot;, err)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;case &amp;lt;-s.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func (s *SocketClient) receiveHandler(ws *websocket.Conn) {&#xD;&#xA;&#x9;defer close(s.isClosed)&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;messageType, message, err := ws.ReadMessage()&#xD;&#xA;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;s.log.ErrorF(&amp;quot;读取消息 %v&amp;quot;, err)&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;switch messageType {&#xD;&#xA;&#x9;&#x9;case websocket.TextMessage:&#xD;&#xA;&#x9;&#x9;&#x9;var textMessage *wsMessage&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;&#x9;err = json.Unmarshal(message, &amp;amp;textMessage)&#xD;&#xA;&#x9;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;s.log.ErrorF(&amp;quot;消息格式错误: %v&amp;quot;, err)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;&#x9;switch textMessage.Type {&#xD;&#xA;&#x9;&#x9;&#x9;        ...&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Golang 简易WS服务 - 服务端</title>
      <link>/post/2023/02/21/39/</link>
      <pubDate>Tue, 21 Feb 2023 00:00:00 +0000</pubDate>
      <guid>/post/2023/02/21/39/</guid>
      <description>&lt;h2 id=&#34;本次开发主要使用了gorilla-websocket软件包&#34;&gt;本次开发主要使用了Gorilla Websocket软件包&lt;/h2&gt;&#xA;&lt;h3 id=&#34;客户端结构体&#34;&gt;客户端结构体&lt;/h3&gt;&#xA;&lt;p&gt;维护socket连接，保存客户端信息&lt;/p&gt;&#xA;&lt;h4 id=&#34;代码&#34;&gt;代码&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package contorller&#xD;&#xA;&#xD;&#xA;import (&#xD;&#xA;&#x9;&amp;quot;encoding/json&amp;quot;&#xD;&#xA;&#x9;&amp;quot;fmt&amp;quot;&#xD;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/model&amp;quot;&#xD;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/enum&amp;quot;&#xD;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/logger&amp;quot;&#xD;&#xA;&#x9;&amp;quot;git.myscrm.cn/vr/server-yk-app-builder/pkg/response&amp;quot;&#xD;&#xA;&#x9;&amp;quot;github.com/gorilla/websocket&amp;quot;&#xD;&#xA;&#x9;&amp;quot;strconv&amp;quot;&#xD;&#xA;&#x9;&amp;quot;time&amp;quot;&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;const (&#xD;&#xA;&#x9;// pingWait is the maximum time in seconds to wait for a ping from&#xD;&#xA;&#x9;pingWait = 20 * time.Second&#xD;&#xA;&#x9;// Maximum message size allowed from peer.&#xD;&#xA;&#x9;maxMessageSize = 512&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;type wsClient struct {&#xD;&#xA;&#x9;manager  *wsManager&#xD;&#xA;&#x9;id       string&#xD;&#xA;&#x9;desc     string&#xD;&#xA;&#x9;conn     *websocket.Conn&#xD;&#xA;&#x9;status   enum.ClientStatus&#xD;&#xA;&#x9;send     chan []byte&#xD;&#xA;&#x9;isClosed chan bool&#xD;&#xA;&#x9;lastPing time.Time&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func newWsClient(manager *wsManager, conn *websocket.Conn, id, name, ip string) *wsClient {&#xD;&#xA;&#x9;return &amp;amp;wsClient{&#xD;&#xA;&#x9;&#x9;manager:  manager,&#xD;&#xA;&#x9;&#x9;id:       id,&#xD;&#xA;&#x9;&#x9;desc:     fmt.Sprintf(&amp;quot;客户端(%s, %s)&amp;quot;, name, ip),&#xD;&#xA;&#x9;&#x9;conn:     conn,&#xD;&#xA;&#x9;&#x9;status:   enum.ClientStatusOffline,&#xD;&#xA;&#x9;&#x9;send:     make(chan []byte),&#xD;&#xA;&#x9;&#x9;isClosed: make(chan bool),&#xD;&#xA;&#x9;&#x9;lastPing: time.Now(),&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// Read 读取客户端发送过来的消息&#xD;&#xA;func (c *wsClient) Read() {&#xD;&#xA;&#x9;defer func() {&#xD;&#xA;&#x9;&#x9;c.unRegister()&#xD;&#xA;&#x9;&#x9;logger.Info(c.desc, &amp;quot;read协程退出&amp;quot;)&#xD;&#xA;&#x9;}()&#xD;&#xA;&#xD;&#xA;&#x9;c.conn.SetReadLimit(maxMessageSize)&#xD;&#xA;&#x9;c.conn.SetPingHandler(func(text string) error {&#xD;&#xA;&#x9;&#x9;// 只需要知道客户端还活着就行，不需要回复&#xD;&#xA;&#x9;&#x9;c.lastPing = time.Now()&#xD;&#xA;&#x9;&#x9;// 更新客户端状态&#xD;&#xA;&#x9;&#x9;clientStatus, _ := strconv.ParseInt(text, 10, 32)&#xD;&#xA;&#x9;&#x9;c.status = enum.ClientStatus(int32(clientStatus))&#xD;&#xA;&#x9;&#x9;return nil&#xD;&#xA;&#x9;})&#xD;&#xA;&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;msgType, data, err := c.conn.ReadMessage()&#xD;&#xA;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;logger.Error(c.desc, &amp;quot;c.conn.ReadMessage&amp;quot;, err.Error())&#xD;&#xA;&#x9;&#x9;&#x9;break&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;switch msgType {&#xD;&#xA;&#x9;&#x9;case websocket.TextMessage:&#xD;&#xA;&#x9;&#x9;&#x9;var msg *model.WsMessage&#xD;&#xA;&#x9;&#x9;&#x9;err = json.Unmarshal(data, &amp;amp;msg)&#xD;&#xA;&#x9;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;logger.Error(c.desc, &amp;quot;json.Unmarshal&amp;quot;, err.Error())&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;break&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;&#x9;&#x9;switch msg.Type {&#xD;&#xA;&#x9;&#x9;&#x9;default:&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;logger.Info(c.desc, &amp;quot;未知消息类型&amp;quot;, string(data))&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;c.send &amp;lt;- data&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// Write 把对应消息写回客户端&#xD;&#xA;func (c *wsClient) Write() {&#xD;&#xA;&#x9;defer func() {&#xD;&#xA;&#x9;&#x9;logger.Info(c.desc, &amp;quot;write协程退出&amp;quot;)&#xD;&#xA;&#x9;&#x9;c.unRegister()&#xD;&#xA;&#x9;}()&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;case &amp;lt;-c.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;case msg := &amp;lt;-c.send:&#xD;&#xA;&#x9;&#x9;&#x9;err := c.conn.WriteMessage(websocket.TextMessage, msg)&#xD;&#xA;&#x9;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;logger.Error(c.desc, &amp;quot;c.conn.WriteMessage&amp;quot;, err.Error())&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// Check 检测客户端是否超时&#xD;&#xA;func (c *wsClient) Check() {&#xD;&#xA;&#x9;defer func() {&#xD;&#xA;&#x9;&#x9;logger.Info(c.desc, &amp;quot;check协程退出&amp;quot;)&#xD;&#xA;&#x9;}()&#xD;&#xA;&#x9;ticker := time.NewTicker(pingWait / 6)&#xD;&#xA;&#x9;for {&#xD;&#xA;&#x9;&#x9;select {&#xD;&#xA;&#x9;&#x9;case &amp;lt;-c.isClosed:&#xD;&#xA;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;case &amp;lt;-ticker.C:&#xD;&#xA;&#x9;&#x9;&#x9;// 主动关闭连接&#xD;&#xA;&#x9;&#x9;&#x9;if time.Now().Sub(c.lastPing) &amp;gt; pingWait {&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;response.WsReturnErr(c.conn, enum.WsDataErr, &amp;quot;客户端超时，主动关闭连接&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;logger.Info(c.desc, &amp;quot;客户端超时，主动关闭连接&amp;quot;)&#xD;&#xA;&#x9;&#x9;&#x9;&#x9;return&#xD;&#xA;&#x9;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func (c *wsClient) unRegister() {&#xD;&#xA;&#x9;if c.manager.clients[c.id] != nil {&#xD;&#xA;&#x9;&#x9;c.manager.unRegister &amp;lt;- c&#xD;&#xA;&#x9;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;&#xA;&lt;p&gt;应当在控制器/入口处&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 协程更好的进行错误处理</title>
      <link>/post/2022/06/02/29/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      <guid>/post/2022/06/02/29/</guid>
      <description>&lt;h2 id=&#34;利用-channel-来传输多个-goroutine-中的-errors&#34;&gt;利用 &lt;code&gt;channel&lt;/code&gt; 来传输多个 goroutine 中的 errors&lt;/h2&gt;&#xA;&lt;p&gt;Go 的经典哲学：不要通过共享内存来通信，而是通过通信来实现内存共享&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {&#xD;&#xA;&#x9;cherrors := make(chan error)&#xD;&#xA;&#x9;wgDone := make(chan bool)&#xD;&#xA;&#xD;&#xA;&#x9;var wg sync.WaitGroup&#xD;&#xA;&#x9;wg.Add(2)&#xD;&#xA;&#x9;go func() {&#xD;&#xA;&#x9;&#x9;//... 业务逻辑&#xD;&#xA;&#x9;&#x9;wg.Done()&#xD;&#xA;&#x9;}()&#xD;&#xA;&#x9;go func() {&#xD;&#xA;&#x9;&#x9;//... 业务逻辑&#xD;&#xA;&#x9;&#x9;err := returnErr()&#xD;&#xA;&#x9;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;&#x9;cherrors &amp;lt;- err&#xD;&#xA;&#x9;&#x9;}&#xD;&#xA;&#x9;&#x9;wg.Done()&#xD;&#xA;&#x9;}()&#xD;&#xA;&#x9;go func() {&#xD;&#xA;&#x9;&#x9;wg.Wait()&#xD;&#xA;&#x9;&#x9;close(wgDone)&#xD;&#xA;&#x9;}()&#xD;&#xA;&#xD;&#xA;&#x9;select {&#xD;&#xA;&#x9;case &amp;lt;-wgDone:&#xD;&#xA;&#x9;&#x9;break&#xD;&#xA;&#x9;case err := &amp;lt;-cherrors:&#xD;&#xA;&#x9;&#x9;close(cherrors)&#xD;&#xA;&#x9;&#x9;fmt.Println(err)&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;time.Sleep(time.Second)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func returnErr() error {&#xD;&#xA;&#x9;return errors.New(&amp;quot;出错啦。。我是错误信息&amp;quot;)&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;使用-syncerrgroup&#34;&gt;使用 &lt;code&gt;sync/errgroup&lt;/code&gt;&lt;/h2&gt;&#xA;&lt;p&gt;使用官方提供的&lt;code&gt;golang.org/x/sync/errgroup&lt;/code&gt;标准库&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang Defer理解</title>
      <link>/post/2022/01/13/25/</link>
      <pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate>
      <guid>/post/2022/01/13/25/</guid>
      <description>&lt;h3 id=&#34;结论&#34;&gt;结论&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;多个defer的执行顺序为&lt;code&gt;先进后出&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;匿名返回值是在&lt;code&gt;return&lt;/code&gt;执行时被声明，有名返回值则是在函数声明的同时被声明，因此在&lt;code&gt;defer&lt;/code&gt;语句中只能访问有名返回值，而不能直接访问匿名返回值&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;return&lt;/code&gt;其实应该包含前后两个步骤：第一步是给返回值赋值（若为有名返回值则直接赋值，若为匿名返回值则先声明再赋值）；第二步是调用&lt;code&gt;RET&lt;/code&gt;返回指令并传入返回值，而&lt;code&gt;RET&lt;/code&gt;则会检查&lt;code&gt;defer&lt;/code&gt;是否存在，若存在就先逆序插播defer语句，最后RET携带返回值退出函数&lt;/li&gt;&#xA;&lt;li&gt;延迟函数的参数在 defer 语句出现时就已经确定下来了（defer声明时会先计算确定参数的值，defer推迟执行的仅是其函数体）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;解释&#34;&gt;解释&lt;/h3&gt;&#xA;&lt;h5 id=&#34;结论1&#34;&gt;结论1&lt;/h5&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xD;&#xA;&#xD;&#xA;func main() {&#xD;&#xA;    for i := 0; i &amp;lt; 4; i++ {&#xD;&#xA;        defer fmt.Print(i)&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // Output:&#xD;&#xA;    // 3&#xD;&#xA;    // 2&#xD;&#xA;    // 1&#xD;&#xA;    // 0&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h5 id=&#34;结论2和结论3&#34;&gt;结论2和结论3&lt;/h5&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xD;&#xA;&#xD;&#xA;import (&#xD;&#xA;    &amp;quot;fmt&amp;quot;&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;func main() {&#xD;&#xA;    fmt.Println(a())&#xD;&#xA;&#xD;&#xA;    // Output:&#xD;&#xA;    // 1&#xD;&#xA;    // 2&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// 无名返回值&#xD;&#xA;func a() int {&#xD;&#xA;    defer func() { i++ }()&#xD;&#xA;    return 1&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;// 有名返回值&#xD;&#xA;func a() (i int) {&#xD;&#xA;    defer func() { i++ }()&#xD;&#xA;    return 1&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h5 id=&#34;结论4&#34;&gt;结论4&lt;/h5&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;package main&#xD;&#xA;&#xD;&#xA;import (&#xD;&#xA;    &amp;quot;fmt&amp;quot;&#xD;&#xA;)&#xD;&#xA;&#xD;&#xA;func main() {&#xD;&#xA;    a()&#xD;&#xA;    b()&#xD;&#xA;&#xD;&#xA;    // Output:&#xD;&#xA;    // 0&#xD;&#xA;    // enter: b&#xD;&#xA;    // in b&#xD;&#xA;    // leave: b&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func a() {&#xD;&#xA;    i := 0&#xD;&#xA;    defer fmt.Println(i) // 调用时i已经确定为0&#xD;&#xA;    i++&#xD;&#xA;    return&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func trace(s string) s {&#xD;&#xA;    fmt.Println(&amp;quot;enter: &amp;quot;, s)&#xD;&#xA;    return s&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func un(s) {&#xD;&#xA;    fmt.Println(&amp;quot;leave: &amp;quot;, s)&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;func b() {&#xD;&#xA;    defer un(trace(&amp;quot;b&amp;quot;)) // defer声明时会先计算确定参数的值，即执行了trace()，defer推迟执行的仅是其函数体un()&#xD;&#xA;    fmt.Println(&amp;quot;in b&amp;quot;)&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/#53-defer&#34;&gt;《Go语言设计与实现》&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://cloud.tencent.com/developer/article/1410243&#34;&gt;Golang中defer、return、返回值之间执行顺序的坑&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/huang_yong_peng/article/details/82950743&#34;&gt;理解Golang中defer的使用&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Casbin 理解</title>
      <link>/post/2021/12/31/24/</link>
      <pubDate>Fri, 31 Dec 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/12/31/24/</guid>
      <description>&lt;h3 id=&#34;rbac&#34;&gt;RBAC&lt;/h3&gt;&#xA;&lt;p&gt;model.conf&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;[request_definition]&#xD;&#xA;r = sub, obj, act&#xD;&#xA;&#xD;&#xA;[policy_definition]&#xD;&#xA;p = sub, obj, act&#xD;&#xA;&#xD;&#xA;[role_definition]&#xD;&#xA;g = _, _&#xD;&#xA;&#xD;&#xA;[policy_effect]&#xD;&#xA;e = some(where (p.eft == allow))&#xD;&#xA;&#xD;&#xA;[matchers]&#xD;&#xA;m = g(r.sub, p.sub) &amp;amp;&amp;amp; r.obj == p.obj &amp;amp;&amp;amp; r.act == p.act&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;casbin_rule&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;p, alice, data1, read&#xD;&#xA;p, bob, data2, write&#xD;&#xA;p, data2_admin, data2, read&#xD;&#xA;p, data2_admin, data2, write&#xD;&#xA;&#xD;&#xA;g, alice, data2_admin&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;粗略将&lt;code&gt;sub&lt;/code&gt;可以理解为角色、用户，将&lt;code&gt;obj&lt;/code&gt;理解为资源，将&lt;code&gt;act&lt;/code&gt;理解为操作&#xA;当&lt;code&gt;sub&lt;/code&gt;为用户时，即用户直接对资源进行授权&#xA;当&lt;code&gt;sub&lt;/code&gt;为角色时，即用户分配有某角色，某角色对资源进行授权&lt;/p&gt;&#xA;&lt;p&gt;从上面的例子可以看出&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;alice&lt;/code&gt;被授予了对&lt;code&gt;data1&lt;/code&gt;资源的读权限&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;bob&lt;/code&gt;被授予了对&lt;code&gt;data2&lt;/code&gt;资源的写权限&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;data2_admin&lt;/code&gt;被授予了&lt;code&gt;data2&lt;/code&gt;的读写权限，我们可以把&lt;code&gt;data2_admin&lt;/code&gt;可以理解为角色&lt;/li&gt;&#xA;&lt;li&gt;将&lt;code&gt;alice&lt;/code&gt;分配有&lt;code&gt;data2_admin&lt;/code&gt;角色，则&lt;code&gt;alice&lt;/code&gt;此时具有对&lt;code&gt;data2&lt;/code&gt;的读写权限&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;p：&lt;code&gt;用户、角色&lt;/code&gt;对&lt;code&gt;资源&lt;/code&gt;的授权&#xA;g：将&lt;code&gt;用户&lt;/code&gt;分配有&lt;code&gt;角色&lt;/code&gt;组&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang 通过通道控制携程数量</title>
      <link>/post/2021/11/02/23/</link>
      <pubDate>Tue, 02 Nov 2021 17:31:00 +0000</pubDate>
      <guid>/post/2021/11/02/23/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func main() {&#xD;&#xA;&#x9;var wg sync.WaitGroup&#xD;&#xA;&#x9;var ch = make(chan bool, 10)&#xD;&#xA;    for {&#xD;&#xA;        wg.Add(1)&#xD;&#xA;        ch &amp;lt;- true&#xD;&#xA;        go func() {&#xD;&#xA;            defer func() {&#xD;&#xA;                &amp;lt;- ch&#xD;&#xA;                wg.Done()&#xD;&#xA;            }()&#xD;&#xA;            // 逻辑&#xD;&#xA;            ...&#xD;&#xA;        }()&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    wg.Wait()&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Homebrew 安装软件加速</title>
      <link>/post/2021/10/23/22/</link>
      <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/10/23/22/</guid>
      <description>&lt;h2 id=&#34;加速&#34;&gt;加速&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;安装代理软件 &lt;a href=&#34;https://github.com/yichengchen/clashX&#34;&gt;https://github.com/yichengchen/clashX&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;两种方法&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;方法一（好处：可控，需要进行brew更新才使用；坏处：较为繁琐）&lt;/p&gt;&#xA;&lt;p&gt;在&lt;code&gt;.bashrc&lt;/code&gt;或&lt;code&gt;.zshrc&lt;/code&gt;设置&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ALIAS&#xD;&#xA;alias proxy=&amp;quot;export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890; echo &#39;Proxy on&#39;&amp;quot;&#xD;&#xA;alias unproxy=&amp;quot;unset https_proxy http_proxy all_proxy; echo &#39;Proxy off&#39;&amp;quot;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;生效&lt;code&gt;source .zshrc&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;每次iTerm2设置登录执行&lt;code&gt;proxy&lt;/code&gt;或手动执行&lt;code&gt;proxy&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;方法二（好处：便捷；坏处：可能影响其他命令）&lt;/p&gt;&#xA;&lt;p&gt;在&lt;code&gt;.bashrc&lt;/code&gt;或&lt;code&gt;.zshrc&lt;/code&gt;设置&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Proxy&#xD;&#xA;export https_proxy=http://127.0.0.1:7890&#xD;&#xA;export http_proxy=http://127.0.0.1:7890&#xD;&#xA;export all_proxy=socks5://127.0.0.1:7890&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;生效&lt;code&gt;source .zshrc&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;执行命令&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/bin/bash -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&amp;quot;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;按照指令安装&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;执行命令查看是否正常&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew -v&#xD;&#xA;&#xA;# output:&#xD;&#xA;# Homebrew 3.2.17-133-g890190c&#xD;&#xA;# Homebrew/homebrew-core (git revision 5d84b1431d6; last commit 2021-10-23)&#xD;&#xA;# Homebrew/homebrew-cask (git revision 65500e81bf; last commit 2021-10-23)&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;更新 Homebrew 自己&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew update&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查看哪些安装包需要更新：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew outdated&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;列出已安装包&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew list&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;更新&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew upgrade             # 更新所有的包&#xD;&#xA;brew upgrade $FORMULA    # 更新指定的包&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;清理旧版本&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew cleanup             # 清理所有包的旧版本&#xD;&#xA;brew cleanup $FORMULA    # 清理指定包的旧版本&#xD;&#xA;brew cleanup -n          # 查看可清理的旧版本包，不执行实际操作&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;锁定不想更新的包&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew pin $FORMULA      # 锁定某个包&#xD;&#xA;brew unpin $FORMULA    # 取消锁定&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查看安装包的相关信息&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew info $FORMULA    # 显示某个包的信息&#xD;&#xA;brew info             # 显示安装了包数量，文件数量，和总占用空间&#xD;&#xA;brew deps --installed --tree # 查看已安装的包的依赖，树形显示&#xD;&#xA;# `brew info` 可以查看包的相关信息，最有用的应该是包依赖和相应的命令。比如 Nginx 会提醒你怎么加 launchctl，PostgreSQL 会告诉你如何迁移数据库。这些信息会在包安装完成后自动显示，如果忘了的话可以用这个命令很方便地查看。&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;brew rm $FORMULA                # 删除某个包&#xD;&#xA;brew uninstall --force $FORMULA # 删除所有版本&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Golang AES-128/GCM &#43; BASE64 加密</title>
      <link>/post/2021/03/15/14/</link>
      <pubDate>Mon, 15 Mar 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/03/15/14/</guid>
      <description>&lt;p&gt;需求背景：接入网络游戏防沉迷系统，其中请求体body需要进行加密，和签名&lt;/p&gt;&#xA;&lt;h4 id=&#34;加密&#34;&gt;加密&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func GCMEncrypt(secretKey, originalText string) (string, error) {&#xD;&#xA;&#x9;// 密钥需要解码&#xD;&#xA;&#x9;key, _ := hex.DecodeString(secretKey)&#xD;&#xA;&#x9;block, err := aes.NewCipher(key)&#xD;&#xA;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, err&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;aesGcm, err := cipher.NewGCM(block)&#xD;&#xA;&#x9;if err != nil {&#xD;&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, err&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;&#xD;&#xA;&#x9;// 向量&#xD;&#xA;&#x9;nonce := make([]byte, aesGcm.NonceSize())&#xD;&#xA;&#x9;if _, err := io.ReadFull(rand.Reader, nonce); err != nil {&#xD;&#xA;&#x9;&#x9;return &amp;quot;&amp;quot;, err&#xD;&#xA;&#x9;}&#xD;&#xA;&#xD;&#xA;&#x9;cipherText := aesGcm.Seal(nonce, nonce, []byte(originalText), nil)&#xD;&#xA;&#xD;&#xA;&#x9;// encode as base64 string&#xD;&#xA;&#x9;encoded := base64.StdEncoding.EncodeToString(cipherText)&#xD;&#xA;&#x9;return encoded, nil&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;签名&#34;&gt;签名&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (s *encryptService) Sign(headers, body map[string]string) string {&#xD;&#xA;&#x9;var data string&#xD;&#xA;&#x9;var keys []string&#xD;&#xA;&#x9;// key排序&#xD;&#xA;&#x9;for k := range headers {&#xD;&#xA;&#x9;&#x9;keys = append(keys, k)&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;sort.Strings(keys)&#xD;&#xA;&#xD;&#xA;&#x9;// 拼接&#xD;&#xA;&#x9;for _, k := range keys {&#xD;&#xA;&#x9;&#x9;data = data + k + headers[k]&#xD;&#xA;&#x9;}&#xD;&#xA;&#x9;data = s.appSecret + data + gconv.String(body)&#xD;&#xA;&#xD;&#xA;&#x9;// 对字符串进行sha256哈希&#xD;&#xA;&#x9;h := sha256.New()&#xD;&#xA;&#x9;h.Write([]byte(data))&#xD;&#xA;&#x9;sum := h.Sum(nil)&#xD;&#xA;&#x9;return hex.EncodeToString(sum)&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h4 id=&#34;使用&#34;&gt;使用&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 参数初始化&#xD;&#xA;headers := map[string]string{&#xD;&#xA;&#x9;&amp;quot;appId&amp;quot;:      &amp;quot;xxxxxxxx&amp;quot;,&#xD;&#xA;&#x9;&amp;quot;bizId&amp;quot;:      &amp;quot;xxxxxxxx&amp;quot;,&#xD;&#xA;&#x9;&amp;quot;timestamps&amp;quot;: strconv.Itoa(int(time.Now().UnixNano() / 1e6)),&#xD;&#xA;}&#xD;&#xA;// 请求体加密&#xD;&#xA;jsonByte, _ := json.Marshal(req)&#xD;&#xA;cipher, _ := GCMEncrypt(string(jsonByte), &#39;xxxxxxxxx&#39;) // 第二个参数是密钥&#xD;&#xA;body := map[string]string{&#xD;&#xA;&#x9;&amp;quot;data&amp;quot;: cipher,&#xD;&#xA;}&#xD;&#xA;// 生成签名&#xD;&#xA;headers[&amp;quot;sign&amp;quot;] = Encrypt.Sign(headers, body)&#xD;&#xA;headers[&amp;quot;Content-Type&amp;quot;] = &amp;quot;application/json&amp;quot;&#xD;&#xA;.....发http请求&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Laravel 契约和门面简单解读</title>
      <link>/post/2020/03/30/11/</link>
      <pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate>
      <guid>/post/2020/03/30/11/</guid>
      <description>&lt;p&gt;最近笔者正在理解Larvael服务容器、服务提供者、门面、契约的关系。&#xA;今天主要是记录自己借Laravel自带的Cache模块进行一个讲解。&lt;/p&gt;&#xA;&lt;h3 id=&#34;代码和流程&#34;&gt;代码和流程&lt;/h3&gt;&#xA;&lt;p&gt;首先我们打开&lt;code&gt;config\app.php&lt;/code&gt;中&lt;code&gt;providers&lt;/code&gt;下有一个服务提供者&lt;code&gt;Illuminate\Cache\CacheServiceProvider::class&lt;/code&gt;&lt;br&gt;&#xA;我们看看他的服务提供者是怎么写的：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;public function register()&#xD;&#xA;    {&#xD;&#xA;        $this-&amp;gt;app-&amp;gt;singleton(&#39;cache&#39;, function ($app) {&#xD;&#xA;            return new CacheManager($app);&#xD;&#xA;        });&#xD;&#xA;&#xD;&#xA;        $this-&amp;gt;app-&amp;gt;singleton(&#39;cache.store&#39;, function ($app) {&#xD;&#xA;            return $app[&#39;cache&#39;]-&amp;gt;driver();&#xD;&#xA;        });&#xD;&#xA;&#xD;&#xA;        $this-&amp;gt;app-&amp;gt;singleton(&#39;cache.psr6&#39;, function ($app) {&#xD;&#xA;            return new Psr16Adapter($app[&#39;cache.store&#39;]);&#xD;&#xA;        });&#xD;&#xA;&#xD;&#xA;        $this-&amp;gt;app-&amp;gt;singleton(&#39;memcached.connector&#39;, function () {&#xD;&#xA;            return new MemcachedConnector;&#xD;&#xA;        });&#xD;&#xA;    }&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;我们主要看&lt;code&gt;cache&lt;/code&gt;这个门面，它所单例绑定的是&lt;code&gt;CacheManager&lt;/code&gt;，我们继续深入&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;?php&#xD;&#xA;&#xD;&#xA;namespace Illuminate\Cache;&#xD;&#xA;&#xD;&#xA;use Aws\DynamoDb\DynamoDbClient;&#xD;&#xA;use Closure;&#xD;&#xA;use Illuminate\Contracts\Cache\Factory as FactoryContract;&#xD;&#xA;use Illuminate\Contracts\Cache\Store;&#xD;&#xA;use Illuminate\Contracts\Events\Dispatcher as DispatcherContract;&#xD;&#xA;use Illuminate\Support\Arr;&#xD;&#xA;use InvalidArgumentException;&#xD;&#xA;&#xD;&#xA;/**&#xD;&#xA; * @mixin \Illuminate\Contracts\Cache\Repository&#xD;&#xA; */&#xD;&#xA;class CacheManager implements FactoryContract&#xD;&#xA;{&#xD;&#xA;    /**&#xD;&#xA;     * The application instance.&#xD;&#xA;     *&#xD;&#xA;     * @var \Illuminate\Contracts\Foundation\Application&#xD;&#xA;     */&#xD;&#xA;    protected $app;&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * The array of resolved cache stores.&#xD;&#xA;     *&#xD;&#xA;     * @var array&#xD;&#xA;     */&#xD;&#xA;    protected $stores = [];&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * The registered custom driver creators.&#xD;&#xA;     *&#xD;&#xA;     * @var array&#xD;&#xA;     */&#xD;&#xA;    protected $customCreators = [];&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Create a new Cache manager instance.&#xD;&#xA;     *&#xD;&#xA;     * @param  \Illuminate\Contracts\Foundation\Application  $app&#xD;&#xA;     * @return void&#xD;&#xA;     */&#xD;&#xA;    public function __construct($app)&#xD;&#xA;    {&#xD;&#xA;        $this-&amp;gt;app = $app;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Get a cache store instance by name, wrapped in a repository.&#xD;&#xA;     *&#xD;&#xA;     * @param  string|null  $name&#xD;&#xA;     * @return \Illuminate\Contracts\Cache\Repository&#xD;&#xA;     */&#xD;&#xA;    public function store($name = null)&#xD;&#xA;    {&#xD;&#xA;        $name = $name ?: $this-&amp;gt;getDefaultDriver();&#xD;&#xA;&#xD;&#xA;        return $this-&amp;gt;stores[$name] = $this-&amp;gt;get($name);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Get a cache driver instance.&#xD;&#xA;     *&#xD;&#xA;     * @param  string|null  $driver&#xD;&#xA;     * @return \Illuminate\Contracts\Cache\Repository&#xD;&#xA;     */&#xD;&#xA;    public function driver($driver = null)&#xD;&#xA;    {&#xD;&#xA;        return $this-&amp;gt;store($driver);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Attempt to get the store from the local cache.&#xD;&#xA;     *&#xD;&#xA;     * @param  string  $name&#xD;&#xA;     * @return \Illuminate\Contracts\Cache\Repository&#xD;&#xA;     */&#xD;&#xA;    protected function get($name)&#xD;&#xA;    {&#xD;&#xA;        return $this-&amp;gt;stores[$name] ?? $this-&amp;gt;resolve($name);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Resolve the given store.&#xD;&#xA;     *&#xD;&#xA;     * @param  string  $name&#xD;&#xA;     * @return \Illuminate\Contracts\Cache\Repository&#xD;&#xA;     *&#xD;&#xA;     * @throws \InvalidArgumentException&#xD;&#xA;     */&#xD;&#xA;    protected function resolve($name)&#xD;&#xA;    {&#xD;&#xA;        $config = $this-&amp;gt;getConfig($name);&#xD;&#xA;&#xD;&#xA;        if (is_null($config)) {&#xD;&#xA;            throw new InvalidArgumentException(&amp;quot;Cache store [{$name}] is not defined.&amp;quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        if (isset($this-&amp;gt;customCreators[$config[&#39;driver&#39;]])) {&#xD;&#xA;            return $this-&amp;gt;callCustomCreator($config);&#xD;&#xA;        } else {&#xD;&#xA;            $driverMethod = &#39;create&#39;.ucfirst($config[&#39;driver&#39;]).&#39;Driver&#39;;&#xD;&#xA;&#xD;&#xA;            if (method_exists($this, $driverMethod)) {&#xD;&#xA;                return $this-&amp;gt;{$driverMethod}($config);&#xD;&#xA;            } else {&#xD;&#xA;                throw new InvalidArgumentException(&amp;quot;Driver [{$config[&#39;driver&#39;]}] is not supported.&amp;quot;);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Call a custom driver creator.&#xD;&#xA;     *&#xD;&#xA;     * @param  array  $config&#xD;&#xA;     * @return mixed&#xD;&#xA;     */&#xD;&#xA;    protected function callCustomCreator(array $config)&#xD;&#xA;    {&#xD;&#xA;        return $this-&amp;gt;customCreators[$config[&#39;driver&#39;]]($this-&amp;gt;app, $config);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    ......&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Create an instance of the file cache driver.&#xD;&#xA;     *&#xD;&#xA;     * @param  array  $config&#xD;&#xA;     * @return \Illuminate\Cache\Repository&#xD;&#xA;     */&#xD;&#xA;    protected function createFileDriver(array $config)&#xD;&#xA;    {&#xD;&#xA;        return $this-&amp;gt;repository(new FileStore($this-&amp;gt;app[&#39;files&#39;], $config[&#39;path&#39;]));&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Create a new cache repository with the given implementation.&#xD;&#xA;     *&#xD;&#xA;     * @param  \Illuminate\Contracts\Cache\Store  $store&#xD;&#xA;     * @return \Illuminate\Cache\Repository&#xD;&#xA;     */&#xD;&#xA;    public function repository(Store $store)&#xD;&#xA;    {&#xD;&#xA;        return tap(new Repository($store), function ($repository) {&#xD;&#xA;            $this-&amp;gt;setEventDispatcher($repository);&#xD;&#xA;        });&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Set the event dispatcher on the given repository instance.&#xD;&#xA;     *&#xD;&#xA;     * @param  \Illuminate\Cache\Repository  $repository&#xD;&#xA;     * @return void&#xD;&#xA;     */&#xD;&#xA;    protected function setEventDispatcher(Repository $repository)&#xD;&#xA;    {&#xD;&#xA;        if (! $this-&amp;gt;app-&amp;gt;bound(DispatcherContract::class)) {&#xD;&#xA;            return;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        $repository-&amp;gt;setEventDispatcher(&#xD;&#xA;            $this-&amp;gt;app[DispatcherContract::class]&#xD;&#xA;        );&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    ......&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Get the cache connection configuration.&#xD;&#xA;     *&#xD;&#xA;     * @param  string  $name&#xD;&#xA;     * @return array&#xD;&#xA;     */&#xD;&#xA;    protected function getConfig($name)&#xD;&#xA;    {&#xD;&#xA;        return $this-&amp;gt;app[&#39;config&#39;][&amp;quot;cache.stores.{$name}&amp;quot;];&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    ......&#xD;&#xA;&#xD;&#xA;    /**&#xD;&#xA;     * Dynamically call the default driver instance.&#xD;&#xA;     *&#xD;&#xA;     * @param  string  $method&#xD;&#xA;     * @param  array  $parameters&#xD;&#xA;     * @return mixed&#xD;&#xA;     */&#xD;&#xA;    public function __call($method, $parameters)&#xD;&#xA;    {&#xD;&#xA;        return $this-&amp;gt;store()-&amp;gt;$method(...$parameters);&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;我们以Laravel默认的File存储讲起：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
